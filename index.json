[
{
	"uri": "https://ned14.github.io/outcome/requirements/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Outcome is a header only C++ 14 library known to work on these compiler-platform combinations or better:\n clang 4.0.1 (LLVM) [FreeBSD, Linux, OS X, Windows] GCC 6.3 [Linux]  Partially working compilers:\n GCC 5.4.1 is highly usable so long as you don\u0026rsquo;t use Outcome in a constexpr evaluation context. Visual Studio 2017.2 can compile varying degrees of the test suite, indeed it has sufficient C++ 14 language support. The problem is in the backend which internal compiler errors. Chances are very good that a future compiler update will fix this. clang 3.5 - 3.9 can compile varying degrees of the test suite, the problem is lack of complete and unbuggy C++ 14 language support.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": "Todo\ngraph TD A1{\"result#lt;T, E#gt;\"} --\"Success\"-- B1[\"T value()\"] A1 --\"Failure\"-- C1[\"E error()\"] A2{\"outcome#lt;T, EC, E|P#gt;\"} --\"Success\"-- B2[\"T value()\"] A2 --\"Failure\"-- C2[\"EC error()\"] A2 -- D2((\"Either\")) D2 --\"Abort\"-- E2[\"E exception()\"] D2 --\"Payload\"-- F2[\"P payload()\"]  "
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_outcome.md/",
	"title": "outcome&lt;R, S, P&gt;",
	"tags": [],
	"description": "",
	"content": " Header file outcome.hpp #define OUTCOME_OUTCOME_HPP namespace outcome_v2_xxx { class bad_outcome_access; namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } struct no_payload_type; struct no_exception_type; namespace impl { template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_failure_observers; template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class outcome_failure_observers\u0026lt;Base, R, std::error_code, std::exception_ptr, NoValuePolicy\u0026gt;; } namespace policy { template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; } template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class R, class S = std::error_code, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome; template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()==std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()!=std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); template \u0026lt;class R, class S, class P, class N\u0026gt; void swap(outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); namespace policy { template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow; } namespace impl { } } Class outcome_v2_xxx::bad_outcome_access class bad_outcome_access : public std::logic_error { public: bad_outcome_access(const char* what); }; Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\nNamespace outcome_v2_xxx::trait namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } Namespace for traits\nClass template outcome_v2_xxx::trait::is_exception_ptr [Error code interpretation policy] template \u0026lt;class P\u0026gt; struct is_exception_ptr : std::integral_constant\u0026lt;_Bool, std::is_constructible\u0026lt;std::exception_ptr, P\u0026gt;::value\u0026gt; { }; Trait for whether type P is to be considered a payload to an exception.\nStruct outcome_v2_xxx::no_payload_type struct no_payload_type { no_payload_type() = delete; }; Placeholder type to indicate there is no payload type\nStruct outcome_v2_xxx::no_exception_type struct no_exception_type { no_exception_type() = delete; }; Placeholder type to indicate there is no exception type\nClass template outcome_v2_xxx::impl::outcome_payload_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers : public Base { public: using payload_type = P; using Base::Base; constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; constexpr payload_type\u0026amp; payload() \u0026amp;; constexpr const payload_type\u0026amp; payload() const \u0026amp;; constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; }; The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::outcome_payload_observers::assume_payload (1) constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; (2) constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; (3) constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; (4) constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; Access payload without runtime checks.\nReturns: Reference to the held payload_type according to overload.\nFunction outcome_v2_xxx::impl::outcome_payload_observers::payload (1) constexpr payload_type\u0026amp; payload() \u0026amp;; (2) constexpr const payload_type\u0026amp; payload() const \u0026amp;; (3) constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; (4) constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; Access payload with runtime checks.\nReturns: Reference to the held payload_type according to overload.\nRequires: The outcome to have an payload state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::outcome_exception_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers : public Base { public: using exception_type = P; using Base::Base; constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; constexpr exception_type\u0026amp; exception() \u0026amp;; constexpr const exception_type\u0026amp; exception() const \u0026amp;; constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; }; The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::outcome_exception_observers::assume_exception (1) constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; (2) constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; (3) constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; (4) constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; Access exception without runtime checks.\nReturns: Reference to the held exception_type according to overload.\nFunction outcome_v2_xxx::impl::outcome_exception_observers::exception (1) constexpr exception_type\u0026amp; exception() \u0026amp;; (2) constexpr const exception_type\u0026amp; exception() const \u0026amp;; (3) constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; (4) constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; Access exception with runtime checks.\nReturns: Reference to the held exception_type according to overload.\nRequires: The outcome to have an exception state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::outcome_failure_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_failure_observers : public Base { public: using Base::Base; }; The failure observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nAlias template outcome_v2_xxx::policy::default_outcome_policy [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\nFunction template outcome_v2_xxx::hook_outcome_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is first created by conversion from one of its possible types. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type, error_type, std::pair\u0026lt;error_type, payload_type\u0026gt; or exception_type.  Function template outcome_v2_xxx::hook_outcome_copy_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is created by copying from another outcome or result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_outcome_move_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is created by moving from another outcome or result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_outcome_in_place_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is created by in place construction. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type, error_type, std::pair\u0026lt;error_type, payload_type\u0026gt; or exception_type.  Class template outcome_v2_xxx::outcome [outcome\u0026lt;R, S, P\u0026gt; implementation] template \u0026lt;class R, class S = std::error_code, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome : public 'hidden' { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = S; using payload_exception_type = P; using payload_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; using exception_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; template \u0026lt;class T, class U = S, class V = P\u0026gt; using rebind = outcome\u0026lt;T, U, P\u0026gt;; using value_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;value_type, error_type\u0026gt;::value||std::is_same\u0026lt;value_type, payload_exception_type\u0026gt;::value, typename base::_value_type, value_type\u0026gt;; using error_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;error_type, value_type\u0026gt;::value||std::is_same\u0026lt;error_type, payload_exception_type\u0026gt;::value, typename base::_error_type, error_type\u0026gt;; using payload_exception_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;payload_exception_type, value_type\u0026gt;::value||std::is_same\u0026lt;payload_exception_type, error_type\u0026gt;::value, disable_in_place_payload_exception_type, payload_exception_type\u0026gt;; protected: detail::devoid\u0026lt;payload_exception_type\u0026gt; _ptr; public: template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;exception_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator==(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()==std::declval\u0026lt;V\u0026gt;())); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator!=(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()!=std::declval\u0026lt;V\u0026gt;())); template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); void swap(outcome\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;payload_exception_type\u0026gt;::value); rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; }; Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\nParameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n P - The optional type of the payload/exception result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret types S and P when a wide observation of a not present value occurs.\n  Type alias outcome_v2_xxx::outcome::value_type using value_type = R; The success type.\nType alias outcome_v2_xxx::outcome::status_error_type using status_error_type = S; The S type configured\nType alias outcome_v2_xxx::outcome::error_type using error_type = S; The failure type.\nType alias outcome_v2_xxx::outcome::payload_exception_type using payload_exception_type = P; The P type configured.\nType alias outcome_v2_xxx::outcome::payload_type using payload_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; The payload type, always no_payload_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is true.\nType alias outcome_v2_xxx::outcome::exception_type using exception_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; The exception type, always no_exception_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is false.\nAlias template outcome_v2_xxx::outcome::rebind template \u0026lt;class T, class U = S, class V = P\u0026gt; using rebind = outcome\u0026lt;T, U, P\u0026gt;; Used to rebind this outcome to a different outcome type\nType alias outcome_v2_xxx::outcome::value_type_if_enabled using value_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;value_type, error_type\u0026gt;::value||std::is_same\u0026lt;value_type, payload_exception_type\u0026gt;::value, typename base::_value_type, value_type\u0026gt;; Used to disable in place type construction when value_type is ambiguous with error_type or payload_exception_type.\nType alias outcome_v2_xxx::outcome::error_type_if_enabled using error_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;error_type, value_type\u0026gt;::value||std::is_same\u0026lt;error_type, payload_exception_type\u0026gt;::value, typename base::_error_type, error_type\u0026gt;; Used to disable in place type construction when error_type is ambiguous with value_type or payload_exception_type.\nType alias outcome_v2_xxx::outcome::payload_exception_type_if_enabled using payload_exception_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;payload_exception_type, value_type\u0026gt;::value||std::is_same\u0026lt;payload_exception_type, error_type\u0026gt;::value, disable_in_place_payload_exception_type, payload_exception_type\u0026gt;; Used to disable in place type construction when payload_exception_type is ambiguous with value_type or error_type.\nFunction template outcome_v2_xxx::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful outcome.\nEffects: Initialises the outcome with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, is not constructible to exception_type and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to an errored outcome.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, is not constructible to payload_exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); Converting constructor to an errored outcome + payload/exception.\nEffects: Initialises the outcome with a error_type and a payload_exception_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Type U is constructible to payload_exception_type, is not constructible to value_type.\nThrows: Any exception the construction of error_type(T) and payload_exception_type(U) might throw.\nParameters:\n t - The value from which to initialise the error_type.\n u - The value from which to initialise the payload_exception_type.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;exception_type, T\u0026gt;::value); Converting constructor to an excepted outcome.\nEffects: Initialises the outcome with a exception_type.\nRequires: trait::is_exception_ptr\u0026lt;P\u0026gt; must be true; Type T is constructible to exception_type, is not constructible to value_type, is not constructible to status_error_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of exception_type(T) might throw.\nParameters:\n t - The value from which to initialise the exception_type.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Explicit converting copy constructor from a compatible outcome type.\nEffects: Initialises the outcome with a copy of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Implicit converting copy constructor from a compatible outcome type.\nEffects: Initialises the outcome with a copy of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Explicit converting move constructor from a compatible outcome type.\nEffects: Initialises the outcome with a move of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Implicit converting move constructor from a compatible outcome type.\nEffects: Initialises the outcome with a move of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Explicit converting copy constructor from a compatible result type.\nEffects: Initialises the outcome with a copy of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Implicit converting copy constructor from a compatible result type.\nEffects: Initialises the outcome with a copy of the compatible result.\nRequires: Both outcome\u0026rsquo;serror_type and status_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction ofstatus_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Explicit converting move constructor from a compatible result type.\nEffects: Initialises the outcome with a move of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Implicit converting move constructor from a compatible result type.\nEffects: Initialises the outcome with a move of the compatible result.\nRequires: Both outcome\u0026rsquo;s error_type and status_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: payload_exception_type is void or Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(Args...) might throw.\nParameters:\n args - Arguments with which to in place construct.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: The initializer list + Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(il, Args...) might throw.\nParameters:\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Comparison operator outcome_v2_xxx::outcome::operator== template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator==(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()==std::declval\u0026lt;V\u0026gt;())); True if equal to the other outcome.\nEffects: Calls the operator== operation on each of the three stored items until one returns false.\nRequires: That the expression of calling operator== on each of the three stored items is a valid expression.\nThrows: Any exception the individual operator== operations might throw.\nParameters:\n o - The other outcome to compare to.  Comparison operator outcome_v2_xxx::outcome::operator!= template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator!=(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()!=std::declval\u0026lt;V\u0026gt;())); True if not equal to the other outcome.\nEffects: Calls the operator!= operation on each of the three stored items until one returns true.\nRequires: That the expression of calling operator!= on each of the three stored items is a valid expression.\nThrows: Any exception the individual operator!= operations might throw.\nParameters:\n o - The other outcome to compare to.  Comparison operator outcome_v2_xxx::outcome::operator== template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); True if equal to the other result.\nEffects: Calls the operator== operation on each of the two stored items until one returns false.\nRequires: That the expression of calling operator== on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator== operations might throw.\nParameters:\n o - The other result to compare to.  Comparison operator outcome_v2_xxx::outcome::operator!= template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); True if not equal to the other result.\nEffects: Calls the operator!= operation on each of the two stored items until one returns true.\nRequires: That the expression of calling operator!= on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator!= operations might throw.\nParameters:\n o - The other result to compare to.  Function outcome_v2_xxx::outcome::swap void swap(outcome\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;payload_exception_type\u0026gt;::value); Swaps this result with another result\nEffects: Any R and/or S is swapped along with the metadata tracking them.\nFunction outcome_v2_xxx::outcome::as_void rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; Returns this outcome rebound to void with any errored and payload state copied.\nRequires: This outcome to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::outcome::as_void rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; Returns this outcome rebound to void with any errored and payload state moved.\nRequires: This outcome to have a failed state, else whatever assume_error() would do.\nComparison operator outcome_v2_xxx::operator== template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()==std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); True if the result is equal to the outcome\nEffects: Calls b == a.\nRequires: That the expression b == a is a valid expression.\nThrows: Any exception that b == a might throw.\nParameters:\n a - The result to compare.\n b - The outcome to compare.\n  Comparison operator outcome_v2_xxx::operator!= template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()!=std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); True if the result is not equal to the outcome\nEffects: Calls b != a.\nRequires: That the expression b != a is a valid expression.\nThrows: Any exception that b != a might throw.\nParameters:\n a - The result to compare.\n b - The outcome to compare.\n  Function template outcome_v2_xxx::swap template \u0026lt;class R, class S, class P, class N\u0026gt; void swap(outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); Specialise swap for outcome.\nEffects: Calls a.swap(b).\nClass template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If outcome does not have a value, if it has an exception it rethrows it via std::rethrow_exception(), if has an error it throws a std::system_error(error()), else it throws bad_outcome_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If outcome does not have an error, it throws bad_outcome_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have a payload, it throws bad_outcome_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, it throws bad_outcome_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/",
	"title": "API reference",
	"tags": [],
	"description": "",
	"content": " OUTCOME_ENABLE_POSITIVE_STATUS\n OUTCOME_ERROR_FROM_EXCEPTION_HPP\n OUTCOME_IOSTREAM_SUPPORT_HPP\n OUTCOME_OUTCOME_HPP\n OUTCOME_RESULT_HPP\n OUTCOME_TRY - If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure immediately, else set *v( to the unwrapped value\n OUTCOME_TRY2\n OUTCOME_TRYV - If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately\n OUTCOME_TRYV2\n OUTCOME_TRYX - If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately, else become the unwrapped value as an expression. This makes OUTCOME_TRYX(expr) an expression which can be used exactly like the try operator in other languages.\n OUTCOME_TRY_GLUE\n OUTCOME_TRY_GLUE2\n OUTCOME_TRY_HPP\n OUTCOME_TRY_UNIQUE_NAME\n outcome_v2_xxx\n bad_outcome_access - Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\n bad_result_access - Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\n error_from_exception(std::exception_ptr \u0026amp;\u0026amp;, std::error_code)\u0026rdquo;) - Utility function which tries to match the exception in the pointer provided to an equivalent error code. Ought to work for all standard STL types. param e The pointer to an exception to convert. If matched, on exit this is reset to a null pointer. param not_matched The error code to return if we could not match the exception. Note that a null pointer in returns a null error code.\n hook_outcome_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is first created by conversion from one of its possible types. Does nothing.\n hook_outcome_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is created by copying from another outcome or result. Does nothing.\n hook_outcome_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is created by in place construction. Does nothing.\n hook_outcome_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is created by moving from another outcome or result. Does nothing.\n hook_result_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is first created by conversion from one of its possible types. Does nothing.\n hook_result_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is created by copying from another result. Does nothing.\n hook_result_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is created by in place construction. Does nothing.\n hook_result_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is created by moving from another result. Does nothing.\n no_error_type - Placeholder type to indicate there is no error type\n no_exception_type - Placeholder type to indicate there is no exception type\n no_payload_type - Placeholder type to indicate there is no payload type\n no_value_type - Placeholder type to indicate there is no value type\n operator!=(const result\u0026lt;T, U, V\u0026gt; \u0026amp;, const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - True if the result is not equal to the outcome\n operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Serialise an outcome\n operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Serialise a result\n operator==(const result\u0026lt;T, U, V\u0026gt; \u0026amp;, const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - True if the result is equal to the outcome\n operator\u0026gt;\u0026gt;(std::istream \u0026amp;, outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Deserialise an outcome\n operator\u0026gt;\u0026gt;(std::istream \u0026amp;, result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Deserialise a result\n outcome - Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\n print(const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Debug print an outcome\n print(const result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Debug print a result\n result - Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\n swap(outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;, outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Specialise swap for outcome.\n swap(result\u0026lt;R, S, P\u0026gt; \u0026amp;, result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Specialise swap for result.\n try_operation_return_as(T \u0026amp;\u0026amp;)\u0026rdquo;) - Customisation point for changing what the OUTCOME_TRY macros do. This function defaults to returning std::move(v).as_void().\n  outcome_v2_xxx::impl\n outcome_exception_observers - The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n outcome_failure_observers - The failure observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_failure_observers\u0026lt;Base, R, std::error_code, std::exception_ptr, NoValuePolicy\u0026gt;\n outcome_payload_observers - The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n result_error_observers - The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n result_final - The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_storage - The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers - The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n select_result_impl\n  outcome_v2_xxx::policy\n default_outcome_policy - Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\n default_result_policy - Default result\u0026lt;R, S\u0026gt; policy selector.\n error_code_throw_as_system_error - Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\n error_code_throw_as_system_error_exception_rethrow - Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\n exception_ptr_rethrow - Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\n terminate - Policy implementing any wide attempt to access the successful state as calling std::terminate\n throw_directly - Policy interpreting EC as a type to be thrown directly during wide checks.\n  outcome_v2_xxx::trait - Namespace for traits\n is_exception_ptr - Trait for whether type P is to be considered a payload to an exception.    "
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_result.md/",
	"title": "result&lt;R, S&gt;",
	"tags": [],
	"description": "",
	"content": " Header file result.hpp #define OUTCOME_RESULT_HPP #define OUTCOME_ENABLE_POSITIVE_STATUS namespace outcome_v2_xxx { class bad_result_access; struct no_value_type; struct no_error_type; namespace impl { template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage; template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; using select_result_impl = result_error_observers\u0026lt;result_value_observers\u0026lt;result_storage\u0026lt;R, EC, NoValuePolicy\u0026gt;, R, NoValuePolicy\u0026gt;, EC, NoValuePolicy\u0026gt;; template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final; } namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result; template \u0026lt;class R, class S, class P\u0026gt; void swap(result\u0026lt;R, S, P\u0026gt;\u0026amp; a, result\u0026lt;R, S, P\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); } Class outcome_v2_xxx::bad_result_access class bad_result_access : public std::logic_error { public: bad_result_access(const char* what); }; Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\nStruct outcome_v2_xxx::no_value_type struct no_value_type { no_value_type() = delete; }; Placeholder type to indicate there is no value type\nStruct outcome_v2_xxx::no_error_type struct no_error_type { no_error_type() = delete; }; Placeholder type to indicate there is no error type\nClass template outcome_v2_xxx::impl::result_storage template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage { protected: using _value_type = std::conditional_t\u0026lt;std::is_same\u0026lt;R, EC\u0026gt;::value, disable_in_place_value_type, R\u0026gt;; using _error_type = std::conditional_t\u0026lt;std::is_same\u0026lt;R, EC\u0026gt;::value, disable_in_place_error_type, EC\u0026gt;; detail::value_storage_select_impl\u0026lt;_value_type\u0026gt; _state; detail::devoid\u0026lt;_error_type\u0026gt; _error; result_storage() = default; result_storage(const result_storage\u0026amp;) = default; result_storage(result_storage\u0026amp;\u0026amp;) = default; result_storage\u0026amp; operator=(const result_storage\u0026amp;) = default; result_storage\u0026amp; operator=(result_storage\u0026amp;\u0026amp;) = default; template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_error_type\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_error_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); struct compatible_conversion_tag; template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;void, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, void, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;void, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, void, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value); }; The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nClass template outcome_v2_xxx::impl::result_value_observers template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers : public Base { public: using value_type = R; using Base::Base; constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; constexpr value_type\u0026amp; value() \u0026amp;; constexpr const value_type\u0026amp; value() const \u0026amp;; constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; }; The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::result_value_observers::assume_value (1) constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; (2) constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; (3) constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; (4) constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; Access value without runtime checks.\nReturns: Reference to the held value_type according to overload.\nFunction outcome_v2_xxx::impl::result_value_observers::value (1) constexpr value_type\u0026amp; value() \u0026amp;; (2) constexpr const value_type\u0026amp; value() const \u0026amp;; (3) constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; (4) constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; Access value with runtime checks.\nReturns: Reference to the held value_type according to overload.\nRequires: The result to have a successful state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::result_error_observers template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers : public Base { public: using error_type = EC; using Base::Base; constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; constexpr error_type\u0026amp; error() \u0026amp;; constexpr const error_type\u0026amp; error() const \u0026amp;; constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; }; The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::result_error_observers::assume_error (1) constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; (2) constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; (3) constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; (4) constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; Access error without runtime checks.\nReturns: Reference to the held error_type according to overload.\nFunction outcome_v2_xxx::impl::result_error_observers::error (1) constexpr error_type\u0026amp; error() \u0026amp;; (2) constexpr const error_type\u0026amp; error() const \u0026amp;; (3) constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; (4) constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; Access error with runtime checks.\nReturns: Reference to the held error_type according to overload.\nRequires: The result to have a failed state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::result_final template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final : public select_result_impl\u0026lt;R, S, NoValuePolicy\u0026gt; { public: using ::base/'base::base; constexpr operator bool() const noexcept; constexpr bool has_value() const noexcept; constexpr bool has_error() const noexcept; constexpr bool has_payload() const noexcept; constexpr bool has_exception() const noexcept; constexpr bool has_failure() const noexcept; template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); }; The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nConversion operator outcome_v2_xxx::impl::result_final::operator bool constexpr operator bool() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::impl::result_final::has_value constexpr bool has_value() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::impl::result_final::has_error constexpr bool has_error() const noexcept; Checks if has error.\nReturns: True if has error.\nFunction outcome_v2_xxx::impl::result_final::has_payload constexpr bool has_payload() const noexcept; Checks if has payload.\nReturns: True if has payload.\nFunction outcome_v2_xxx::impl::result_final::has_exception constexpr bool has_exception() const noexcept; Checks if has exception.\nReturns: True if has exception.\nFunction outcome_v2_xxx::impl::result_final::has_failure constexpr bool has_failure() const noexcept; Checks if has error or exception.\nReturns: True if has error or exception.\nComparison operator outcome_v2_xxx::impl::result_final::operator== template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); True if equal to the other result.\nEffects: Calls the operator== operation on each of the two stored items until one returns false.\nRequires: That the expression of calling operator== on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator== operations might throw.\nParameters:\n o - The other result to compare to.  Comparison operator outcome_v2_xxx::impl::result_final::operator!= template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); True if not equal to the other result.\nEffects: Calls the operator!= operation on each of the two stored items until one returns true.\nRequires: That the expression of calling operator!= on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator!= operations might throw.\nParameters:\n o - The other result to compare to.  Namespace outcome_v2_xxx::policy namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } Namespace for policies\nClass template outcome_v2_xxx::policy::throw_directly [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct throw_directly { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type to be thrown directly during wide checks.\nFunction template outcome_v2_xxx::policy::throw_directly::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::throw_directly::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::throw_directly::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws that error(), else it throws bad_result_access.\nFunction template outcome_v2_xxx::policy::throw_directly::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome_v2_xxx::policy::error_code_throw_as_system_error [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws a std::system_error(error()), else it throws bad_result_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome_v2_xxx::policy::exception_ptr_rethrow [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it rethrows that error via std::rethrow_exception(), else it throws bad_result_access.\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it throws that error, else it throws bad_result_access.\nStruct outcome_v2_xxx::policy::terminate [Error code interpretation policy] struct terminate { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy implementing any wide attempt to access the successful state as calling std::terminate\nFunction template outcome_v2_xxx::policy::terminate::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, calls std::terminate().\nFunction template outcome_v2_xxx::policy::terminate::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, calls std::terminate().\nFunction template outcome_v2_xxx::policy::terminate::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nFunction template outcome_v2_xxx::policy::terminate::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nAlias template outcome_v2_xxx::policy::default_result_policy [Error code interpretation policy] template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; Default result\u0026lt;R, S\u0026gt; policy selector.\nFunction template outcome_v2_xxx::hook_result_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is first created by conversion from one of its possible types. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type or error_type.  Function template outcome_v2_xxx::hook_result_copy_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is created by copying from another result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_result_move_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is created by moving from another result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_result_in_place_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is created by in place construction. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type or error_type.  Class template outcome_v2_xxx::result [result\u0026lt;R, S\u0026gt; implementation] template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result : public impl::result_final\u0026lt;R, S, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = S; using value_type_if_enabled = typename base::_value_type; using error_type_if_enabled = typename base::_error_type; template \u0026lt;class T, class U = S\u0026gt; using rebind = result\u0026lt;T, U\u0026gt;; protected: struct predicate; public: //=== Default, copy/move constructors and assignment ===// result() = delete; result(result\u0026amp;\u0026amp;) = default; result(const result\u0026amp;) = default; result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; result\u0026amp; operator=(const result\u0026amp;) = default; template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class ErrorCondEnum\u0026gt; constexpr result(ErrorCondEnum\u0026amp;\u0026amp; t) noexcept(noexcept(error_type(make_error_code(std::forward\u0026lt;ErrorCondEnum\u0026gt;(t))))); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); void swap(result\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value); rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; }; Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\nThis is a vocabulary type implementing P0262R0 A Class for Status and Optional Value, albeit with types Status and Value reversed in lexical order. By default S is considered to be a positive status type used to supply additional information about the successful return of a type R. If however the trait trait::status_type_is_negative\u0026lt;S\u0026gt; has been specialised to be true, then S is considered to be a negative status type used to supply information about the cause of failure to return a type R.\ntrait::status_type_is_negative\u0026lt;S\u0026gt; is already set to true for these types (you can specialise in your own types easily):\n std::error_code std::exception_ptr void  When trait::status_type_is_negative\u0026lt;S\u0026gt; is false, the default for NoValuePolicy is:\n If .status() called when there is no status_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  When trait::status_type_is_negative\u0026lt;S\u0026gt; is true, the default for NoValuePolicy is:\n If .value() called when there is no value_type but there is an error_type:   If S convertible to a std::error_code, then throw std::system_error(error()) [policy::error_code_throw_as_system_error\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S convertible to a std::exception_ptr, then std::rethrow_exception(error()) [policy::exception_ptr_rethrow\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S is void, call std::terminate() [policy::terminate\u0026lt;S\u0026gt;] If S is none of the above, then someone has enabled the negative status type trait but did not specify a custom policy. We therefore simply throw error() [policy::throw_directly\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate.   If .error() called when there is no error_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  Parameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret type S when a wide observation of a not present value occurs.\n  Type alias outcome_v2_xxx::result::value_type using value_type = R; The success type.\nType alias outcome_v2_xxx::result::status_error_type using status_error_type = S; The S type configured\nType alias outcome_v2_xxx::result::error_type using error_type = S; The failure type.\nType alias outcome_v2_xxx::result::value_type_if_enabled using value_type_if_enabled = typename base::_value_type; Used to disable in place type construction when value_type and error_type are ambiguous.\nType alias outcome_v2_xxx::result::error_type_if_enabled using error_type_if_enabled = typename base::_error_type; Used to disable in place type construction when value_type and error_type are ambiguous.\nAlias template outcome_v2_xxx::result::rebind template \u0026lt;class T, class U = S\u0026gt; using rebind = result\u0026lt;T, U\u0026gt;; Used to rebind this result to a different result type.\nStruct outcome_v2_xxx::result::predicate struct predicate { using base = 'hidden'; }; Requirement predicates for result.\nDefault constructor outcome_v2_xxx::result::result result() = delete; Default construction is not permitted.\nMove constructor outcome_v2_xxx::result::result result(result\u0026amp;\u0026amp;) = default; Move construction available if value_type and status_error_type implement it.\nCopy constructor outcome_v2_xxx::result::result result(const result\u0026amp;) = default; Copy construction available if value_type and status_error_type implement it.\nAssignment operator outcome_v2_xxx::result::operator= result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; Move assignment available if value_type and status_error_type implement it.\nAssignment operator outcome_v2_xxx::result::operator= result\u0026amp; operator=(const result\u0026amp;) = default; Copy assignment available if value_type and status_error_type implement it.\nFunction template outcome_v2_xxx::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome_v2_xxx::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome_v2_xxx::result::result template \u0026lt;class ErrorCondEnum\u0026gt; constexpr result(ErrorCondEnum\u0026amp;\u0026amp; t) noexcept(noexcept(error_type(make_error_code(std::forward\u0026lt;ErrorCondEnum\u0026gt;(t))))); Special error condition converting constructor to a failure result.\nEffects: Initialises the result with a error_type constructed via make_error_code(t).\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; std::is_error_condition_enum\u0026lt;ErrorCondEnum\u0026gt; must be true, ErrorCondEnum is not constructible to value_type nor error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Finally, the expression error_type(make_error_code(ErrorCondEnum())) must be valid.\nThrows: Any exception the construction of error_type(make_error_code(t)) might throw.\nParameters:\n t - The error condition from which to initialise the error_type.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Explicit converting copy constructor from a compatible result type.\nEffects: Initialises the result with a copy of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source status_error_type can be void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Implicit converting copy constructor from a compatible result type.\nEffects: Initialises the result with a copy of the compatible result.\nRequires: Both result\u0026rsquo;s error_type and status_type need to be constructible, and the source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Explicit converting move constructor from a compatible result type.\nEffects: Initialises the result with a move of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source status_error_type can be void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Implicit converting move constructor from a compatible result type.\nEffects: Initialises the result with a move of the compatible result.\nRequires: Both result\u0026rsquo;s error_type and status_type need to be constructible, and the source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n args - Arguments with which to in place construct.  Function template outcome_v2_xxx::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n args - Arguments with which to in place construct.  Function template outcome_v2_xxx::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function outcome_v2_xxx::result::swap void swap(result\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value); Swaps this result with another result\nEffects: Any R and/or S is swapped along with the metadata tracking them.\nFunction outcome_v2_xxx::result::as_void rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; Returns this result rebound to void with any errored state copied.\nRequires: This result to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::result::as_void rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; Returns this result rebound to void with any errored state moved.\nRequires: This result to have a failed state, else whatever assume_error() would do.\nFunction template outcome_v2_xxx::swap template \u0026lt;class R, class S, class P\u0026gt; void swap(result\u0026lt;R, S, P\u0026gt;\u0026amp; a, result\u0026lt;R, S, P\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); Specialise swap for result.\nEffects: Calls a.swap(b).\n"
},
{
	"uri": "https://ned14.github.io/outcome/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "Todo\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_try.md/",
	"title": "Try operations",
	"tags": [],
	"description": "",
	"content": " Header file try.hpp #define OUTCOME_TRY_HPP #define OUTCOME_TRY_GLUE2(x, y) #define OUTCOME_TRY_GLUE(x, y) #define OUTCOME_TRY_UNIQUE_NAME #define OUTCOME_TRYV2(unique, m) #define OUTCOME_TRY2(unique, v, m) #define OUTCOME_TRYV(m) #define OUTCOME_TRYX(m) #define OUTCOME_TRY(v, m) namespace outcome_v2_xxx { template \u0026lt;class T\u0026gt; typename T::template rebind\u0026lt;void\u0026gt; try_operation_return_as(T\u0026amp;\u0026amp; v); } Macro OUTCOME_TRYV #define OUTCOME_TRYV(m) If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately\nMacro OUTCOME_TRYX #define OUTCOME_TRYX(m) If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately, else become the unwrapped value as an expression. This makes OUTCOME_TRYX(expr) an expression which can be used exactly like the try operator in other languages.\nportable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\nMacro OUTCOME_TRY #define OUTCOME_TRY(v, m) If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure immediately, else set *v( to the unwrapped value\nFunction template outcome_v2_xxx::try_operation_return_as template \u0026lt;class T\u0026gt; typename T::template rebind\u0026lt;void\u0026gt; try_operation_return_as(T\u0026amp;\u0026amp; v); Customisation point for changing what the OUTCOME_TRY macros do. This function defaults to returning std::move(v).as_void().\nEffects: Extracts any state apart from value into a void rebound equivalent.\nRequires: The input value to have a .as_void() member function, and a rebind member template alias.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_utils.md/",
	"title": "Utilities",
	"tags": [],
	"description": "",
	"content": " Header file utils.hpp #define OUTCOME_ERROR_FROM_EXCEPTION_HPP namespace outcome_v2_xxx { std::error_code error_from_exception(std::exception_ptr\u0026amp;\u0026amp; ep, std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept; } Function outcome_v2_xxx::error_from_exception std::error_code error_from_exception(std::exception_ptr\u0026amp;\u0026amp; ep, std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept; Utility function which tries to match the exception in the pointer provided to an equivalent error code. Ought to work for all standard STL types. param e The pointer to an exception to convert. If matched, on exit this is reset to a null pointer. param not_matched The error code to return if we could not match the exception. Note that a null pointer in returns a null error code.\neffects Rethrows the exception in the pointer, and via a long sequence of catch clauses attempts to match the equivalent error code. If a match is found, the pointer is reset to null. If a match is not found, not_matched is returned instead and the pointer is left unmodified.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/iostream_support.md/",
	"title": "iostream support",
	"tags": [],
	"description": "",
	"content": " Header file iostream_support.hpp #define OUTCOME_IOSTREAM_SUPPORT_HPP namespace outcome_v2_xxx { template \u0026lt;class R, class S, class P\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, result\u0026lt;R, S, P\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P\u0026gt; std::string print(const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P, class N\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P, class N\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P, class N\u0026gt; std::string print(const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); } Input operator outcome_v2_xxx::operator\u0026gt;\u0026gt; template \u0026lt;class R, class S, class P\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, result\u0026lt;R, S, P\u0026gt;\u0026amp; v); Deserialise a result\nOutput operator outcome_v2_xxx::operator\u0026lt;\u0026lt; template \u0026lt;class R, class S, class P\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); Serialise a result\nFunction template outcome_v2_xxx::print template \u0026lt;class R, class S, class P\u0026gt; std::string print(const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); Debug print a result\nInput operator outcome_v2_xxx::operator\u0026gt;\u0026gt; template \u0026lt;class R, class S, class P, class N\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); Deserialise an outcome\nOutput operator outcome_v2_xxx::operator\u0026lt;\u0026lt; template \u0026lt;class R, class S, class P, class N\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); Serialise an outcome\nFunction template outcome_v2_xxx::print template \u0026lt;class R, class S, class P, class N\u0026gt; std::string print(const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); Debug print an outcome\n"
},
{
	"uri": "https://ned14.github.io/outcome/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\ngantt dateFormat YYYY-MM title History of the Outcome library Outcome v1: done, des1, 2014-06,2017-05 Boost peer review of v1: done, des2, after des1, 30d Outcome v2: active, des3, after des2, 365d section Events Separated from AFIO v1: crit, done, 2014-06,2d Boost.Expected added: crit, done, 2014-10,2d Boost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,2d Non-allocating future-promise implementation dropped: crit, done, 2016-05,2d C++ 11 support dropped: crit, done, 2016-06,2d Implemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,2d Outcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,2d  The genesis of Outcome v1 The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of metaprogramming being replaced with cleaner variable templates in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;.\nTo finish later \u0026hellip;\n"
},
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 549 commits   @akrzemi1 2 commits   @jenkins-nedprod 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 library Outcome is a C++14 library for reporting and handling function failures in contexts where using C++ exception handling is unsuitable.\nThe reasons for not using exceptions may be different:\n The high relative cost of throwing and catching a C++ exception, Making some or all control paths explicitly detailed to aid code correctness auditing, as opposed to having hidden control paths caused by exceptions potentially thrown from any place, Company\u0026rsquo;s policy to compile with exceptions disabled, Maintaining a code base that was never designed with exception-safety in mind, Parts of the programs/frameworks that themselves implement exception handling and cannot afford to use exceptions, like propagating failure reports across threads, tasks, fibers\u0026hellip;   Outcome can also be used to plug components that potentially throw exceptions into parts of the program that are not exception-safe while retaining all information from the thrown exception objects.\nSample usage Function that may need to report failure needs to reflect that in its return type:\nauto read_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;;  Function read_int_from_file will either return an int or information about the reason for failure.\nIt is possible to inspect the returned state manualy:\nif (auto rslt = read_int_from_file(\u0026quot;config.cfg\u0026quot;)) use_int(rslt.value()); else report_error(rslt.error()); // returns std::error_code  But most of the time you would inspect the object indirectly through a dedicated control statement. An implementation of read_int_from_file that has to (1) open the file, (2) read raw data to a buffer, and (3) interpret it as int, using the following three functions\nauto open_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;Handle\u0026gt;; auto read_data(Handle\u0026amp; h) noexcept -\u0026gt; outcome::result\u0026lt;Buffer\u0026gt;; auto parse(const Buffer\u0026amp; b) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;;  will look like this:\nauto read_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt; { OUTCOME_TRY(handle, open_file(path)); // decltype(handle) == Handle OUTCOME_TRY(buffer, read_data(handle)); // decltype(buffer) == Buffer OUTCOME_TRY(val, parse(buffer)); // decltype(val) == int return val; }  Each occurence of OUTCOME_TRY is a control statement. If the returned result\u0026lt;T\u0026gt; contains an error information, the function is immediatelly returned with result\u0026lt;U\u0026gt; containing the same error information; otherwise object of type T is move-constructed on the stack.\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library is expected to pass a second Boost peer review, and be submitted to WG21 for standardisation into the standard C++ library.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]