[
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/",
	"title": "API reference",
	"tags": [],
	"description": "",
	"content": " OUTCOME_ENABLE_POSITIVE_STATUS - Define to enable positive value + status returns\n OUTCOME_NODISCARD\n OUTCOME_OUTCOME_HPP\n OUTCOME_RESULT_HPP\n OUTCOME_SYMBOL_VISIBLE\n outcome\n bad_outcome_access - Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\n bad_result_access - Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\n in_place_type_t - Aliases std::in_place_type_t\u0026lt;T\u0026gt; if on C++ 17 or later, else defined locally.\n no_error_type - Placeholder type to indicate there is no error type\n no_exception_type - Placeholder type to indicate there is no exception type\n no_payload_type - Placeholder type to indicate there is no payload type\n outcome - Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\n result - Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\n result\u0026lt;void, void, NoValuePolicy\u0026gt; - result\u0026lt;void, void\u0026gt; specialisation.\n  outcome::impl\n outcome_exception_observers - The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n outcome_payload_observers - The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n result_error_observers - The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n result_final - The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_storage - The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers - The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n select_result_impl\n  outcome::policy\n default_outcome_policy - Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\n default_result_policy - Default result\u0026lt;R, S\u0026gt; policy selector.\n error_code_throw_as_system_error - Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\n error_code_throw_as_system_error_exception_rethrow - Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\n exception_ptr_rethrow - Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\n terminate - Policy implementing any wide attempt to access the successful state as calling std::terminate\n throw_directly - Policy interpreting EC as a type to be thrown directly during wide checks.\n  outcome::trait - Namespace for traits\n is_exception_ptr - Trait for whether type P is to be considered a payload to an exception.    "
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "History and Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{\rdisplay:flex;\rflex-flow: wrap;\ralign-content: flex-start\r}\r.ghContributors  div{\rwidth: 50% ;\rdisplay: inline-flex;\rmargin-bottom: 5px;\r}\r.ghContributors  div label{\rpadding-left: 4px ;\r}\r.ghContributors  div span{\rfont-size: x-small;\rpadding-left: 4px ;\r}\r\r\r@ned14\r482 commits\r\r\r@jenkins-nedprod\r1 commits\r\r This documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  "
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 library This is the Outcome library. It is a C++ 14 library intended to aid ultra-lightweight error handling in large C++ codebases, providing a more expressive and type safe alternative to integer error codes or enums.\nUnlike alternative implementations, it works perfectly with exceptions and RTTI disabled and is thus suitable for low-latency/games/finance/SG14 users. One could view Outcome as a minimum overhead universal outcome transport mechanism for C++, hence being named \u0026ldquo;Outcome\u0026rdquo;.\nIf you are familiar with Swift\u0026rsquo;s error code throws or Rust\u0026rsquo;s Result\u0026lt;T, E\u0026gt;, you will find almost identical semantics in the transports provided here. Outcome even has a OUTCOME_TRY macro doing most of the try keyword in Rust and Swift!\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library is expected to pass a second Boost peer review, and be submitted to WG21 for standardisation into the standard C++ library.\n\rOne motivation for this library is to manage errors reported by different means using a single minimum overhead framework. This motivating example should clarify:\n// Imagine the libraries you depend on each use different mechanisms for returning errors namespace outcome = OUTCOME_V2_NAMESPACE; namespace Library1 { // Like the Filesystem and Networking TS, auto fun(std::error_code \u0026amp;) noexcept // returns errors via lvalue ref to an error_code. -\u0026gt; int; // Never throws exceptions. } namespace Library2 { // Throws some exception on error auto fun() -\u0026gt; int; } namespace Library3 { // Returns an int (expected) or some exception  auto fun() noexcept // pointer (unexpected). Never throws exceptions. -\u0026gt; outcome::result\u0026lt;int, std::exception_ptr\u0026gt;; } namespace Library4 // Result is an int (not error) { // or an outcome::error_code_extended (error) auto fun() noexcept // Never throws exceptions. -\u0026gt; outcome::result\u0026lt;int\u0026gt;; } // signalling uniform error Outcome is an int, or an outcome::error_code_extended, // or a std::exception_ptr auto my_fun() noexcept -\u0026gt; outcome::outcome\u0026lt;int\u0026gt; { // all noexcept functions which could call try { // throwing code should always have their std::error_code ec; // bodies wrapped in a try...catch int i = Library1::fun(ec); if (ec) return {outcome::in_place\u0026lt;outcome::error_code_extended\u0026gt;, ec}; // error code returned inside outcome try { i += Library2::fun(); } catch (...) { return std::current_exception(); // exception_ptr returned inside outcome } if (auto rslt1 = Library3::fun()) i += *rslt1; else return rslt1.error(); // error code returned inside outcome OUTCOME_TRY(rslt2, Library4::fun()); // this may return an outcome with an // error code, iff fun() reports failure return i + rslt2; // return outcome with a value } catch (...) { return std::current_exception(); // construct from std::current_exception() } }; // using functions\u0026#39; outcome: int test() { try { int i = my_fun().value(); // throws if not valued return i; } catch (std::exception const\u0026amp; e) { // e can be used to retrieve return inspect_exception_to_your_liking(e); // initial error condition } }  "
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_outcome.md/",
	"title": "outcome&lt;R, S, P&gt;",
	"tags": [],
	"description": "",
	"content": " Header file outcome.hpp #define OUTCOME_OUTCOME_HPP namespace outcome { class bad_outcome_access; namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } struct no_payload_type; struct no_exception_type; namespace impl { template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; } namespace policy { template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; } template \u0026lt;class R, class S = error_code_extended, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome; namespace policy { template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow; } namespace impl { } } Class outcome::bad_outcome_access class bad_outcome_access : public std::logic_error { public: bad_outcome_access(const char* what); }; Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\nNamespace outcome::trait namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } Namespace for traits\nClass template outcome::trait::is_exception_ptr [Error code interpretation policy] template \u0026lt;class P\u0026gt; struct is_exception_ptr : std::integral_constant\u0026lt;_Bool, std::is_constructible\u0026lt;std::exception_ptr, P\u0026gt;::value\u0026gt; { }; Trait for whether type P is to be considered a payload to an exception.\nStruct outcome::no_payload_type struct no_payload_type { no_payload_type() = delete; }; Placeholder type to indicate there is no payload type\nStruct outcome::no_exception_type struct no_exception_type { no_exception_type() = delete; }; Placeholder type to indicate there is no exception type\nClass template outcome::impl::outcome_payload_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers : public Base { public: using payload_type = P; using Base::Base; constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; constexpr payload_type\u0026amp; payload() \u0026amp;; constexpr const payload_type\u0026amp; payload() const \u0026amp;; constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; }; The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::outcome_payload_observers::assume_payload (1) constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; (2) constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; (3) constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; (4) constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; Access payload without runtime checks.\nReturns: Reference to the held payload_type according to overload.\nFunction outcome::impl::outcome_payload_observers::payload (1) constexpr payload_type\u0026amp; payload() \u0026amp;; (2) constexpr const payload_type\u0026amp; payload() const \u0026amp;; (3) constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; (4) constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; Access payload with runtime checks.\nReturns: Reference to the held payload_type according to overload.\nRequires: The outcome to have an payload state, else whatever NoValuePolicy says ought to happen.\nClass template outcome::impl::outcome_exception_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers : public Base { public: using exception_type = P; using Base::Base; constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; constexpr exception_type\u0026amp; exception() \u0026amp;; constexpr const exception_type\u0026amp; exception() const \u0026amp;; constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; }; The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::outcome_exception_observers::assume_exception (1) constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; (2) constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; (3) constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; (4) constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; Access exception without runtime checks.\nReturns: Reference to the held exception_type according to overload.\nFunction outcome::impl::outcome_exception_observers::exception (1) constexpr exception_type\u0026amp; exception() \u0026amp;; (2) constexpr const exception_type\u0026amp; exception() const \u0026amp;; (3) constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; (4) constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; Access exception with runtime checks.\nReturns: Reference to the held exception_type according to overload.\nRequires: The outcome to have an exception state, else whatever NoValuePolicy says ought to happen.\nAlias template outcome::policy::default_outcome_policy [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\nClass template outcome::outcome [outcome\u0026lt;R, S, P\u0026gt; implementation] template \u0026lt;class R, class S = error_code_extended, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome : public 'hidden' { public: //=== Member types ===// using value_type = typename base::value_type; using status_error_type = typename base::status_error_type; using error_type = typename base::error_type; using payload_exception_type = P; using payload_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; using exception_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; protected: 'hidden' _ptr; public: template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); }; Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\nParameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n P - The optional type of the payload/exception result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret types S and P when a wide observation of a not present value occurs.\n  Type alias outcome::outcome::value_type using value_type = typename base::value_type; The success type.\nType alias outcome::outcome::status_error_type using status_error_type = typename base::status_error_type; The S type configured\nType alias outcome::outcome::error_type using error_type = typename base::error_type; The failure type, always no_error_type if trait::status_type_is_negative\u0026lt;S\u0026gt; is false.\nType alias outcome::outcome::payload_exception_type using payload_exception_type = P; The P type configured.\nType alias outcome::outcome::payload_type using payload_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; The payload type, always no_payload_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is true.\nType alias outcome::outcome::exception_type using exception_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; The exception type, always no_exception_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is false.\nFunction template outcome::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful outcome.\nEffects: Initialises the outcome with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, is not constructible to payload_exception_type and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome::outcome::outcome template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); Converting constructor to a successful outcome + payload.\nEffects: Initialises the outcome with a value_type and a payload_type.\nRequires: trait::is_exception_ptr\u0026lt;P\u0026gt; must be false; Type T is constructible to value_type, is not constructible to status_error_type, is not constructible to payload_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Type U is constructible to payload_type, is not constructible to value_type, and is not constructible to status_error_type.\nThrows: Any exception the construction of value_type(T) and payload_type(U) might throw.\nParameters:\n t - The value from which to initialise the value_type.\n u - The value from which to initialise the payload_type.\n  Function template outcome::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to an errored outcome.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, is not constructible to payload_exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome::outcome::outcome template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); Converting constructor to an errored outcome + payload/exception.\nEffects: Initialises the outcome with a error_type and a payload_exception_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, is not constructible to payload_exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Type U is constructible to payload_exception_type, is not constructible to value_type, and is not constructible to error_type.\nThrows: Any exception the construction of error_type(T) and payload_exception_type(U) might throw.\nParameters:\n t - The value from which to initialise the error_type.\n u - The value from which to initialise the payload_exception_type.\n  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Converting copy constructor from a compatible outcome type.\nEffects: Initialises the outcome with a copy of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Converting move constructor from a compatible outcome type.\nEffects: Initialises the outcome with a move of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Converting copy constructor from a compatible result type.\nEffects: Initialises the outcome with a copy of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Converting move constructor from a compatible result type.\nEffects: Initialises the outcome with a move of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: payload_exception_type is void or Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of payload_exception_type.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: The initializer list + Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of payload_exception_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Class template outcome::policy::error_code_throw_as_system_error_exception_rethrow [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If outcome does not have a value, if it has an exception it rethrows it via std::rethrow_exception(), if has an error it throws a std::system_error(error()), else it throws bad_outcome_access.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If outcome does not have an error, it throws bad_outcome_access.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have a payload, it throws bad_outcome_access.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, it throws bad_outcome_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_result.md/",
	"title": "result&lt;R, S&gt;",
	"tags": [],
	"description": "",
	"content": " Header file result.hpp #define OUTCOME_RESULT_HPP #define OUTCOME_SYMBOL_VISIBLE #define OUTCOME_NODISCARD #define OUTCOME_ENABLE_POSITIVE_STATUS namespace outcome { template \u0026lt;class T\u0026gt; struct in_place_type_t; class bad_result_access; struct no_error_type; namespace impl { template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage; template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; using select_result_impl = result_error_observers\u0026lt;result_value_observers\u0026lt;result_storage\u0026lt;R, EC, NoValuePolicy\u0026gt;, R, NoValuePolicy\u0026gt;, EC, NoValuePolicy\u0026gt;; template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final; } namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } template \u0026lt;class R, class S = error_code_extended, class NoValuePolicy = policy::default_result_policy\u0026lt;S\u0026gt; class result; template \u0026lt;class NoValuePolicy\u0026gt; class result\u0026lt;void, void, NoValuePolicy\u0026gt;; } Macro OUTCOME_ENABLE_POSITIVE_STATUS #define OUTCOME_ENABLE_POSITIVE_STATUS Define to enable positive value + status returns\nClass template outcome::in_place_type_t template \u0026lt;class T\u0026gt; struct in_place_type_t { in_place_type_t() = default; }; Aliases std::in_place_type_t\u0026lt;T\u0026gt; if on C++ 17 or later, else defined locally.\nClass outcome::bad_result_access class bad_result_access : public std::logic_error { public: bad_result_access(const char* what); }; Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\nStruct outcome::no_error_type struct no_error_type { no_error_type() = delete; }; Placeholder type to indicate there is no error type\nClass template outcome::impl::result_storage template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage { protected: 'hidden' _state; 'hidden' _error; result_storage() = default; template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;error_type\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;error_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); struct compatible_conversion_tag; template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;void, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, void, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;void, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, void, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); }; The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nClass template outcome::impl::result_value_observers template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers : public Base { public: using value_type = R; using Base::Base; constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; constexpr value_type\u0026amp; value() \u0026amp;; constexpr const value_type\u0026amp; value() const \u0026amp;; constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; }; The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::result_value_observers::assume_value (1) constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; (2) constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; (3) constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; (4) constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; Access value without runtime checks.\nReturns: Reference to the held value_type according to overload.\nFunction outcome::impl::result_value_observers::value (1) constexpr value_type\u0026amp; value() \u0026amp;; (2) constexpr const value_type\u0026amp; value() const \u0026amp;; (3) constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; (4) constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; Access value with runtime checks.\nReturns: Reference to the held value_type according to overload.\nRequires: The result to have a successful state, else whatever NoValuePolicy says ought to happen.\nClass template outcome::impl::result_error_observers template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers : public Base { public: using error_type = EC; using Base::Base; constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; constexpr error_type\u0026amp; error() \u0026amp;; constexpr const error_type\u0026amp; error() const \u0026amp;; constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; }; The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::result_error_observers::assume_error (1) constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; (2) constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; (3) constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; (4) constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; Access error without runtime checks.\nReturns: Reference to the held error_type according to overload.\nFunction outcome::impl::result_error_observers::error (1) constexpr error_type\u0026amp; error() \u0026amp;; (2) constexpr const error_type\u0026amp; error() const \u0026amp;; (3) constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; (4) constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; Access error with runtime checks.\nReturns: Reference to the held error_type according to overload.\nRequires: The result to have a failed state, else whatever NoValuePolicy says ought to happen.\nClass template outcome::impl::result_final template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final : public select_result_impl\u0026lt;R, S, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = S; using ::base/'base::base; constexpr operator bool() const noexcept; constexpr bool has_value() const noexcept; constexpr bool has_error() const noexcept; constexpr bool has_payload() const noexcept; constexpr bool has_exception() const noexcept; }; The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nType alias outcome::impl::result_final::value_type using value_type = R; The success type.\nType alias outcome::impl::result_final::status_error_type using status_error_type = S; The S type configured\nType alias outcome::impl::result_final::error_type using error_type = S; The failure type.\nConversion operator outcome::impl::result_final::operator bool constexpr operator bool() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome::impl::result_final::has_value constexpr bool has_value() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome::impl::result_final::has_error constexpr bool has_error() const noexcept; Checks if has error.\nReturns: True if has error.\nFunction outcome::impl::result_final::has_payload constexpr bool has_payload() const noexcept; Checks if has payload.\nReturns: True if has payload.\nFunction outcome::impl::result_final::has_exception constexpr bool has_exception() const noexcept; Checks if has exception.\nReturns: True if has exception.\nNamespace outcome::policy namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } Namespace for policies\nClass template outcome::policy::throw_directly [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct throw_directly { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type to be thrown directly during wide checks.\nFunction template outcome::policy::throw_directly::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::throw_directly::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome::policy::throw_directly::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws that error(), else it throws bad_result_access.\nFunction template outcome::policy::throw_directly::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome::policy::error_code_throw_as_system_error [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\nFunction template outcome::policy::error_code_throw_as_system_error::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws a std::system_error(error()), else it throws bad_result_access.\nFunction template outcome::policy::error_code_throw_as_system_error::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome::policy::exception_ptr_rethrow [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\nFunction template outcome::policy::exception_ptr_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::exception_ptr_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome::policy::exception_ptr_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it rethrows that error via std::rethrow_exception(), else it throws bad_result_access.\nFunction template outcome::policy::exception_ptr_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it throws that error, else it throws bad_result_access.\nStruct outcome::policy::terminate [Error code interpretation policy] struct terminate { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy implementing any wide attempt to access the successful state as calling std::terminate\nFunction template outcome::policy::terminate::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::terminate::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome::policy::terminate::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions\nEffects: None.\nFunction template outcome::policy::terminate::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction template outcome::policy::terminate::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, calls std::terminate().\nFunction template outcome::policy::terminate::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, calls std::terminate().\nFunction template outcome::policy::terminate::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nFunction template outcome::policy::terminate::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nAlias template outcome::policy::default_result_policy [Error code interpretation policy] template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; Default result\u0026lt;R, S\u0026gt; policy selector.\nClass template outcome::result [result\u0026lt;R, S\u0026gt; implementation] template \u0026lt;class R, class S = error_code_extended, class NoValuePolicy = policy::default_result_policy\u0026lt;S\u0026gt; class result : public impl::result_final\u0026lt;R, S, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = typename base::error_type; //=== Default, copy/move constructors and assignment ===// result() = delete; result(result\u0026amp;\u0026amp;) = default; result(const result\u0026amp;) = default; result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; result\u0026amp; operator=(const result\u0026amp;) = default; template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); }; Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\nThis is a vocabulary type implementing P0262R0 A Class for Status and Optional Value, albeit with types Status and Value reversed in lexical order. By default S is considered to be a positive status type used to supply additional information about the successful return of a type R. If however the trait trait::status_type_is_negative\u0026lt;S\u0026gt; has been specialised to be true, then S is considered to be a negative status type used to supply information about the cause of failure to return a type R.\ntrait::status_type_is_negative\u0026lt;S\u0026gt; is already set to true for these types (you can specialise in your own types easily):\n std::error_code error_code_extended std::exception_ptr void  When trait::status_type_is_negative\u0026lt;S\u0026gt; is false, the default for NoValuePolicy is:\n If .status() called when there is no status_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  When trait::status_type_is_negative\u0026lt;S\u0026gt; is true, the default for NoValuePolicy is:\n If .value() called when there is no value_type but there is an error_type:   If S convertible to a std::error_code, then throw std::system_error(error()) [policy::error_code_throw_as_system_error\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S convertible to a std::exception_ptr, then std::rethrow_exception(error()) [policy::exception_ptr_rethrow\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S is void, call std::terminate() [policy::terminate\u0026lt;S\u0026gt;] If S is none of the above, then someone has enabled the negative status type trait but did not specify a custom policy. We therefore simply throw error() [policy::throw_directly\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate.   If .error() called when there is no error_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  Parameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret type S when a wide observation of a not present value occurs.\n  Type alias outcome::result::value_type using value_type = R; The success type.\nType alias outcome::result::status_error_type using status_error_type = S; The S type configured\nType alias outcome::result::error_type using error_type = typename base::error_type; The failure type.\nDefault constructor outcome::result::result result() = delete; Default construction is not permitted.\nMove constructor outcome::result::result result(result\u0026amp;\u0026amp;) = default; Move construction available if value_type and status_type/error_type implement it.\nCopy constructor outcome::result::result result(const result\u0026amp;) = default; Copy construction available if value_type and status_type/error_type implement it.\nAssignment operator outcome::result::operator= result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; Move assignment available if value_type and status_type/error_type implement it.\nAssignment operator outcome::result::operator= result\u0026amp; operator=(const result\u0026amp;) = default; Copy assignment available if value_type and status_type/error_type implement it.\nFunction template outcome::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Converting copy constructor from a compatible result type.\nEffects: Initialises the result with a copy of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Converting move constructor from a compatible result type.\nEffects: Initialises the result with a move of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n args - Arguments with which to in place construct.\n  Function template outcome::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n args - Arguments with which to in place construct.\n  Function template outcome::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Class template outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt; template \u0026lt;class NoValuePolicy\u0026gt; class result\u0026lt;void, void, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = void; using status_error_type = void; using error_type = void; constexpr void assume_value() const noexcept; constexpr void assume_error() const noexcept; constexpr void value() const; constexpr void error() const; constexpr operator bool() const noexcept; constexpr bool has_value() const noexcept; constexpr bool has_error() const noexcept; }; result\u0026lt;void, void\u0026gt; specialisation.\nType alias outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::value_type using value_type = void; The success type.\nType alias outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::status_error_type using status_error_type = void; The S type configured\nType alias outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::error_type using error_type = void; The failure type.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::assume_value constexpr void assume_value() const noexcept; Does nothing\nReturns: Nothing.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::assume_error constexpr void assume_error() const noexcept; Does nothing\nReturns: Nothing.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::value constexpr void value() const; Does nothing.\nReturns: Nothing.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::error constexpr void error() const; Does nothing.\nReturns: Nothing.\nConversion operator outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::operator bool constexpr operator bool() const noexcept; Checks if has value.\nReturns: False.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::has_value constexpr bool has_value() const noexcept; Checks if has value.\nReturns: False.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::has_error constexpr bool has_error() const noexcept; Checks if has error.\nReturns: False.\n"
}]