[
{
	"uri": "https://ned14.github.io/outcome/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": "Todo\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/",
	"title": "API reference",
	"tags": [],
	"description": "",
	"content": " OUTCOME_ENABLE_POSITIVE_STATUS - Define to enable positive value + status returns\n OUTCOME_NODISCARD\n OUTCOME_OUTCOME_HPP\n OUTCOME_RESULT_HPP\n OUTCOME_SYMBOL_VISIBLE\n outcome\n bad_outcome_access - Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\n bad_result_access - Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\n in_place_type_t - Aliases std::in_place_type_t\u0026lt;T\u0026gt; if on C++ 17 or later, else defined locally.\n no_error_type - Placeholder type to indicate there is no error type\n no_exception_type - Placeholder type to indicate there is no exception type\n no_payload_type - Placeholder type to indicate there is no payload type\n outcome - Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\n result - Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\n result\u0026lt;void, void, NoValuePolicy\u0026gt; - result\u0026lt;void, void\u0026gt; specialisation.\n  outcome::impl\n outcome_exception_observers - The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n outcome_payload_observers - The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n result_error_observers - The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n result_final - The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_storage - The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers - The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n select_result_impl\n  outcome::policy\n default_outcome_policy - Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\n default_result_policy - Default result\u0026lt;R, S\u0026gt; policy selector.\n error_code_throw_as_system_error - Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\n error_code_throw_as_system_error_exception_rethrow - Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\n exception_ptr_rethrow - Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\n terminate - Policy implementing any wide attempt to access the successful state as calling std::terminate\n throw_directly - Policy interpreting EC as a type to be thrown directly during wide checks.\n  outcome::trait - Namespace for traits\n is_exception_ptr - Trait for whether type P is to be considered a payload to an exception.    "
},
{
	"uri": "https://ned14.github.io/outcome/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "Todo\n"
},
{
	"uri": "https://ned14.github.io/outcome/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\ngantt dateFormat YYYY-MM title History of the Outcome library Outcome v1: done, des1, 2014-06,2017-05 Boost peer review of v1: done, des2, after des1, 30d Outcome v2: active, des3, after des2, 365d section Events Separated from AFIO v1: crit, done, 2014-06,2d Boost.Expected added: crit, done, 2014-10,2d Boost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,2d Non-allocating future-promise implementation dropped: crit, done, 2016-05,2d C++ 11 support dropped: crit, done, 2016-06,2d Implemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,2d Outcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,2d  The genesis of Outcome v1 The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of metaprogramming being replaced with cleaner variable templates in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;.\nTo finish later \u0026hellip;\n"
},
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 482 commits   @jenkins-nedprod 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 library graph TD A1{\"result#lt;T, E#gt;\"} --\"Success\"-- B1[\"T value()\"] A1 --\"Failure\"-- C1[\"E error()\"] A2{\"outcome#lt;T, EC, E|P#gt;\"} --\"Success\"-- B2[\"T value()\"] A2 --\"Failure\"-- C2[\"EC error()\"] A2 -- D2((\"Either\")) D2 --\"Abort\"-- E2[\"E exception()\"] D2 --\"Payload\"-- F2[\"P payload()\"]  This is the Outcome library. It is a C++ 14 library intended to aid ultra-lightweight error handling in large C++ codebases, providing a more expressive and type safe alternative to integer error codes or enums.\nUnlike alternative implementations, it works perfectly with exceptions and RTTI disabled and is thus suitable for low-latency/games/finance/SG14 users. One could view Outcome as a minimum overhead universal outcome transport mechanism for C++, hence being named \u0026ldquo;Outcome\u0026rdquo;.\nIf you are familiar with Swift\u0026rsquo;s error code throws or Rust\u0026rsquo;s Result\u0026lt;T, E\u0026gt;, you will find almost identical semantics in the transports provided here. Outcome even has a OUTCOME_TRY macro doing most of the try keyword in Rust and Swift!\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library is expected to pass a second Boost peer review, and be submitted to WG21 for standardisation into the standard C++ library.\n One motivation for this library is to manage errors reported by different means using a single minimum overhead framework. This motivating example should clarify:\n// Imagine the libraries you depend on each use different mechanisms for returning errors namespace outcome = OUTCOME_V2_NAMESPACE; namespace Library1 { // Like the Filesystem and Networking TS, auto fun(std::error_code \u0026amp;) noexcept // returns errors via lvalue ref to an error_code. -\u0026gt; int; // Never throws exceptions. } namespace Library2 { // Throws some exception on error auto fun() -\u0026gt; int; } namespace Library3 { // Returns an int (expected) or some exception  auto fun() noexcept // pointer (unexpected). Never throws exceptions. -\u0026gt; outcome::result\u0026lt;int, std::exception_ptr\u0026gt;; } namespace Library4 // Result is an int (not error) { // or an outcome::error_code_extended (error) auto fun() noexcept // Never throws exceptions. -\u0026gt; outcome::result\u0026lt;int\u0026gt;; } // signalling uniform error Outcome is an int, or an outcome::error_code_extended, // or a std::exception_ptr auto my_fun() noexcept -\u0026gt; outcome::outcome\u0026lt;int\u0026gt; { // all noexcept functions which could call try { // throwing code should always have their std::error_code ec; // bodies wrapped in a try...catch int i = Library1::fun(ec); if (ec) return {outcome::in_place\u0026lt;outcome::error_code_extended\u0026gt;, ec}; // error code returned inside outcome try { i += Library2::fun(); } catch (...) { return std::current_exception(); // exception_ptr returned inside outcome } if (auto rslt1 = Library3::fun()) i += *rslt1; else return rslt1.error(); // error code returned inside outcome OUTCOME_TRY(rslt2, Library4::fun()); // this may return an outcome with an // error code, iff fun() reports failure return i + rslt2; // return outcome with a value } catch (...) { return std::current_exception(); // construct from std::current_exception() } }; // using functions\u0026#39; outcome: int test() { try { int i = my_fun().value(); // throws if not valued return i; } catch (std::exception const\u0026amp; e) { // e can be used to retrieve return inspect_exception_to_your_liking(e); // initial error condition } }  "
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_outcome.md/",
	"title": "outcome&lt;R, S, P&gt;",
	"tags": [],
	"description": "",
	"content": " Header file outcome.hpp #define OUTCOME_OUTCOME_HPP namespace outcome { class bad_outcome_access; namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } struct no_payload_type; struct no_exception_type; namespace impl { template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; } namespace policy { template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; } template \u0026lt;class R, class S = error_code_extended, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome; namespace policy { template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow; } namespace impl { } } Class outcome::bad_outcome_access class bad_outcome_access : public std::logic_error { public: bad_outcome_access(const char* what); }; Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\nNamespace outcome::trait namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } Namespace for traits\nClass template outcome::trait::is_exception_ptr [Error code interpretation policy] template \u0026lt;class P\u0026gt; struct is_exception_ptr : std::integral_constant\u0026lt;_Bool, std::is_constructible\u0026lt;std::exception_ptr, P\u0026gt;::value\u0026gt; { }; Trait for whether type P is to be considered a payload to an exception.\nStruct outcome::no_payload_type struct no_payload_type { no_payload_type() = delete; }; Placeholder type to indicate there is no payload type\nStruct outcome::no_exception_type struct no_exception_type { no_exception_type() = delete; }; Placeholder type to indicate there is no exception type\nClass template outcome::impl::outcome_payload_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers : public Base { public: using payload_type = P; using Base::Base; constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; constexpr payload_type\u0026amp; payload() \u0026amp;; constexpr const payload_type\u0026amp; payload() const \u0026amp;; constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; }; The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::outcome_payload_observers::assume_payload (1) constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; (2) constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; (3) constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; (4) constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; Access payload without runtime checks.\nReturns: Reference to the held payload_type according to overload.\nFunction outcome::impl::outcome_payload_observers::payload (1) constexpr payload_type\u0026amp; payload() \u0026amp;; (2) constexpr const payload_type\u0026amp; payload() const \u0026amp;; (3) constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; (4) constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; Access payload with runtime checks.\nReturns: Reference to the held payload_type according to overload.\nRequires: The outcome to have an payload state, else whatever NoValuePolicy says ought to happen.\nClass template outcome::impl::outcome_exception_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers : public Base { public: using exception_type = P; using Base::Base; constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; constexpr exception_type\u0026amp; exception() \u0026amp;; constexpr const exception_type\u0026amp; exception() const \u0026amp;; constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; }; The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::outcome_exception_observers::assume_exception (1) constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; (2) constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; (3) constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; (4) constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; Access exception without runtime checks.\nReturns: Reference to the held exception_type according to overload.\nFunction outcome::impl::outcome_exception_observers::exception (1) constexpr exception_type\u0026amp; exception() \u0026amp;; (2) constexpr const exception_type\u0026amp; exception() const \u0026amp;; (3) constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; (4) constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; Access exception with runtime checks.\nReturns: Reference to the held exception_type according to overload.\nRequires: The outcome to have an exception state, else whatever NoValuePolicy says ought to happen.\nAlias template outcome::policy::default_outcome_policy [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\nClass template outcome::outcome [outcome\u0026lt;R, S, P\u0026gt; implementation] template \u0026lt;class R, class S = error_code_extended, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome : public 'hidden' { public: //=== Member types ===// using value_type = typename base::value_type; using status_error_type = typename base::status_error_type; using error_type = typename base::error_type; using payload_exception_type = P; using payload_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; using exception_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; protected: 'hidden' _ptr; public: template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); }; Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\nParameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n P - The optional type of the payload/exception result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret types S and P when a wide observation of a not present value occurs.\n  Type alias outcome::outcome::value_type using value_type = typename base::value_type; The success type.\nType alias outcome::outcome::status_error_type using status_error_type = typename base::status_error_type; The S type configured\nType alias outcome::outcome::error_type using error_type = typename base::error_type; The failure type, always no_error_type if trait::status_type_is_negative\u0026lt;S\u0026gt; is false.\nType alias outcome::outcome::payload_exception_type using payload_exception_type = P; The P type configured.\nType alias outcome::outcome::payload_type using payload_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; The payload type, always no_payload_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is true.\nType alias outcome::outcome::exception_type using exception_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; The exception type, always no_exception_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is false.\nFunction template outcome::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful outcome.\nEffects: Initialises the outcome with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, is not constructible to payload_exception_type and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome::outcome::outcome template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); Converting constructor to a successful outcome + payload.\nEffects: Initialises the outcome with a value_type and a payload_type.\nRequires: trait::is_exception_ptr\u0026lt;P\u0026gt; must be false; Type T is constructible to value_type, is not constructible to status_error_type, is not constructible to payload_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Type U is constructible to payload_type, is not constructible to value_type, and is not constructible to status_error_type.\nThrows: Any exception the construction of value_type(T) and payload_type(U) might throw.\nParameters:\n t - The value from which to initialise the value_type.\n u - The value from which to initialise the payload_type.\n  Function template outcome::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to an errored outcome.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, is not constructible to payload_exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome::outcome::outcome template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); Converting constructor to an errored outcome + payload/exception.\nEffects: Initialises the outcome with a error_type and a payload_exception_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, is not constructible to payload_exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Type U is constructible to payload_exception_type, is not constructible to value_type, and is not constructible to error_type.\nThrows: Any exception the construction of error_type(T) and payload_exception_type(U) might throw.\nParameters:\n t - The value from which to initialise the error_type.\n u - The value from which to initialise the payload_exception_type.\n  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Converting copy constructor from a compatible outcome type.\nEffects: Initialises the outcome with a copy of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Converting move constructor from a compatible outcome type.\nEffects: Initialises the outcome with a move of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Converting copy constructor from a compatible result type.\nEffects: Initialises the outcome with a copy of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Converting move constructor from a compatible result type.\nEffects: Initialises the outcome with a move of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: payload_exception_type is void or Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of payload_exception_type.\n args - Arguments with which to in place construct.\n  Function template outcome::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: The initializer list + Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of payload_exception_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Class template outcome::policy::error_code_throw_as_system_error_exception_rethrow [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If outcome does not have a value, if it has an exception it rethrows it via std::rethrow_exception(), if has an error it throws a std::system_error(error()), else it throws bad_outcome_access.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If outcome does not have an error, it throws bad_outcome_access.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have a payload, it throws bad_outcome_access.\nFunction template outcome::policy::error_code_throw_as_system_error_exception_rethrow::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, it throws bad_outcome_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_result.md/",
	"title": "result&lt;R, S&gt;",
	"tags": [],
	"description": "",
	"content": " Header file result.hpp #define OUTCOME_RESULT_HPP #define OUTCOME_SYMBOL_VISIBLE #define OUTCOME_NODISCARD #define OUTCOME_ENABLE_POSITIVE_STATUS namespace outcome { template \u0026lt;class T\u0026gt; struct in_place_type_t; class bad_result_access; struct no_error_type; namespace impl { template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage; template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; using select_result_impl = result_error_observers\u0026lt;result_value_observers\u0026lt;result_storage\u0026lt;R, EC, NoValuePolicy\u0026gt;, R, NoValuePolicy\u0026gt;, EC, NoValuePolicy\u0026gt;; template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final; } namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } template \u0026lt;class R, class S = error_code_extended, class NoValuePolicy = policy::default_result_policy\u0026lt;S\u0026gt; class result; template \u0026lt;class NoValuePolicy\u0026gt; class result\u0026lt;void, void, NoValuePolicy\u0026gt;; } Macro OUTCOME_ENABLE_POSITIVE_STATUS #define OUTCOME_ENABLE_POSITIVE_STATUS Define to enable positive value + status returns\nClass template outcome::in_place_type_t template \u0026lt;class T\u0026gt; struct in_place_type_t { in_place_type_t() = default; }; Aliases std::in_place_type_t\u0026lt;T\u0026gt; if on C++ 17 or later, else defined locally.\nClass outcome::bad_result_access class bad_result_access : public std::logic_error { public: bad_result_access(const char* what); }; Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\nStruct outcome::no_error_type struct no_error_type { no_error_type() = delete; }; Placeholder type to indicate there is no error type\nClass template outcome::impl::result_storage template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage { protected: 'hidden' _state; 'hidden' _error; result_storage() = default; template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;error_type\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;error_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); struct compatible_conversion_tag; template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;void, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, void, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;void, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, void, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); }; The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nClass template outcome::impl::result_value_observers template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers : public Base { public: using value_type = R; using Base::Base; constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; constexpr value_type\u0026amp; value() \u0026amp;; constexpr const value_type\u0026amp; value() const \u0026amp;; constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; }; The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::result_value_observers::assume_value (1) constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; (2) constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; (3) constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; (4) constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; Access value without runtime checks.\nReturns: Reference to the held value_type according to overload.\nFunction outcome::impl::result_value_observers::value (1) constexpr value_type\u0026amp; value() \u0026amp;; (2) constexpr const value_type\u0026amp; value() const \u0026amp;; (3) constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; (4) constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; Access value with runtime checks.\nReturns: Reference to the held value_type according to overload.\nRequires: The result to have a successful state, else whatever NoValuePolicy says ought to happen.\nClass template outcome::impl::result_error_observers template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers : public Base { public: using error_type = EC; using Base::Base; constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; constexpr error_type\u0026amp; error() \u0026amp;; constexpr const error_type\u0026amp; error() const \u0026amp;; constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; }; The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome::impl::result_error_observers::assume_error (1) constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; (2) constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; (3) constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; (4) constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; Access error without runtime checks.\nReturns: Reference to the held error_type according to overload.\nFunction outcome::impl::result_error_observers::error (1) constexpr error_type\u0026amp; error() \u0026amp;; (2) constexpr const error_type\u0026amp; error() const \u0026amp;; (3) constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; (4) constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; Access error with runtime checks.\nReturns: Reference to the held error_type according to overload.\nRequires: The result to have a failed state, else whatever NoValuePolicy says ought to happen.\nClass template outcome::impl::result_final template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final : public select_result_impl\u0026lt;R, S, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = S; using ::base/'base::base; constexpr operator bool() const noexcept; constexpr bool has_value() const noexcept; constexpr bool has_error() const noexcept; constexpr bool has_payload() const noexcept; constexpr bool has_exception() const noexcept; }; The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nType alias outcome::impl::result_final::value_type using value_type = R; The success type.\nType alias outcome::impl::result_final::status_error_type using status_error_type = S; The S type configured\nType alias outcome::impl::result_final::error_type using error_type = S; The failure type.\nConversion operator outcome::impl::result_final::operator bool constexpr operator bool() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome::impl::result_final::has_value constexpr bool has_value() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome::impl::result_final::has_error constexpr bool has_error() const noexcept; Checks if has error.\nReturns: True if has error.\nFunction outcome::impl::result_final::has_payload constexpr bool has_payload() const noexcept; Checks if has payload.\nReturns: True if has payload.\nFunction outcome::impl::result_final::has_exception constexpr bool has_exception() const noexcept; Checks if has exception.\nReturns: True if has exception.\nNamespace outcome::policy namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } Namespace for policies\nClass template outcome::policy::throw_directly [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct throw_directly { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type to be thrown directly during wide checks.\nFunction template outcome::policy::throw_directly::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::throw_directly::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome::policy::throw_directly::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws that error(), else it throws bad_result_access.\nFunction template outcome::policy::throw_directly::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome::policy::error_code_throw_as_system_error [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\nFunction template outcome::policy::error_code_throw_as_system_error::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome::policy::error_code_throw_as_system_error::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws a std::system_error(error()), else it throws bad_result_access.\nFunction template outcome::policy::error_code_throw_as_system_error::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome::policy::exception_ptr_rethrow [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\nFunction template outcome::policy::exception_ptr_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::exception_ptr_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome::policy::exception_ptr_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it rethrows that error via std::rethrow_exception(), else it throws bad_result_access.\nFunction template outcome::policy::exception_ptr_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it throws that error, else it throws bad_result_access.\nStruct outcome::policy::terminate [Error code interpretation policy] struct terminate { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy implementing any wide attempt to access the successful state as calling std::terminate\nFunction template outcome::policy::terminate::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome::policy::terminate::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome::policy::terminate::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions\nEffects: None.\nFunction template outcome::policy::terminate::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction template outcome::policy::terminate::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, calls std::terminate().\nFunction template outcome::policy::terminate::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, calls std::terminate().\nFunction template outcome::policy::terminate::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nFunction template outcome::policy::terminate::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nAlias template outcome::policy::default_result_policy [Error code interpretation policy] template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; Default result\u0026lt;R, S\u0026gt; policy selector.\nClass template outcome::result [result\u0026lt;R, S\u0026gt; implementation] template \u0026lt;class R, class S = error_code_extended, class NoValuePolicy = policy::default_result_policy\u0026lt;S\u0026gt; class result : public impl::result_final\u0026lt;R, S, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = typename base::error_type; //=== Default, copy/move constructors and assignment ===// result() = delete; result(result\u0026amp;\u0026amp;) = default; result(const result\u0026amp;) = default; result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; result\u0026amp; operator=(const result\u0026amp;) = default; template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); }; Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\nThis is a vocabulary type implementing P0262R0 A Class for Status and Optional Value, albeit with types Status and Value reversed in lexical order. By default S is considered to be a positive status type used to supply additional information about the successful return of a type R. If however the trait trait::status_type_is_negative\u0026lt;S\u0026gt; has been specialised to be true, then S is considered to be a negative status type used to supply information about the cause of failure to return a type R.\ntrait::status_type_is_negative\u0026lt;S\u0026gt; is already set to true for these types (you can specialise in your own types easily):\n std::error_code error_code_extended std::exception_ptr void  When trait::status_type_is_negative\u0026lt;S\u0026gt; is false, the default for NoValuePolicy is:\n If .status() called when there is no status_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  When trait::status_type_is_negative\u0026lt;S\u0026gt; is true, the default for NoValuePolicy is:\n If .value() called when there is no value_type but there is an error_type:   If S convertible to a std::error_code, then throw std::system_error(error()) [policy::error_code_throw_as_system_error\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S convertible to a std::exception_ptr, then std::rethrow_exception(error()) [policy::exception_ptr_rethrow\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S is void, call std::terminate() [policy::terminate\u0026lt;S\u0026gt;] If S is none of the above, then someone has enabled the negative status type trait but did not specify a custom policy. We therefore simply throw error() [policy::throw_directly\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate.   If .error() called when there is no error_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  Parameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret type S when a wide observation of a not present value occurs.\n  Type alias outcome::result::value_type using value_type = R; The success type.\nType alias outcome::result::status_error_type using status_error_type = S; The S type configured\nType alias outcome::result::error_type using error_type = typename base::error_type; The failure type.\nDefault constructor outcome::result::result result() = delete; Default construction is not permitted.\nMove constructor outcome::result::result result(result\u0026amp;\u0026amp;) = default; Move construction available if value_type and status_type/error_type implement it.\nCopy constructor outcome::result::result result(const result\u0026amp;) = default; Copy construction available if value_type and status_type/error_type implement it.\nAssignment operator outcome::result::operator= result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; Move assignment available if value_type and status_type/error_type implement it.\nAssignment operator outcome::result::operator= result\u0026amp; operator=(const result\u0026amp;) = default; Copy assignment available if value_type and status_type/error_type implement it.\nFunction template outcome::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Converting copy constructor from a compatible result type.\nEffects: Initialises the result with a copy of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Converting move constructor from a compatible result type.\nEffects: Initialises the result with a move of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n args - Arguments with which to in place construct.\n  Function template outcome::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n args - Arguments with which to in place construct.\n  Function template outcome::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Class template outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt; template \u0026lt;class NoValuePolicy\u0026gt; class result\u0026lt;void, void, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = void; using status_error_type = void; using error_type = void; constexpr void assume_value() const noexcept; constexpr void assume_error() const noexcept; constexpr void value() const; constexpr void error() const; constexpr operator bool() const noexcept; constexpr bool has_value() const noexcept; constexpr bool has_error() const noexcept; }; result\u0026lt;void, void\u0026gt; specialisation.\nType alias outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::value_type using value_type = void; The success type.\nType alias outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::status_error_type using status_error_type = void; The S type configured\nType alias outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::error_type using error_type = void; The failure type.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::assume_value constexpr void assume_value() const noexcept; Does nothing\nReturns: Nothing.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::assume_error constexpr void assume_error() const noexcept; Does nothing\nReturns: Nothing.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::value constexpr void value() const; Does nothing.\nReturns: Nothing.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::error constexpr void error() const; Does nothing.\nReturns: Nothing.\nConversion operator outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::operator bool constexpr operator bool() const noexcept; Checks if has value.\nReturns: False.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::has_value constexpr bool has_value() const noexcept; Checks if has value.\nReturns: False.\nFunction outcome::result\u0026lt;void, void, NoValuePolicy\u0026gt;::has_error constexpr bool has_error() const noexcept; Checks if has error.\nReturns: False.\n"
}]