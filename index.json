[
{
	"uri": "https://ned14.github.io/outcome/requirements/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Outcome is a header only C++ 14 library known to work on these compiler-platform combinations or better:\n clang 4.0.1 (LLVM) [FreeBSD, Linux, OS X] GCC 6.3 [Linux] Visual Studio 2017 [Windows] XCode 9 [MacOS]  It is worth turning on C++ 17 if you can, there are many usability and performance improvements. If your compiler implements the Concepts TS, it is worth turning support on. Support is automatically detected and used.\nPartially working compilers:\n GCC 5.4.1 is highly usable so long as you don\u0026rsquo;t use Outcome in a constexpr evaluation context. clang 3.5 - 3.9 can compile varying degrees of the test suite, the problem is lack of complete and unbuggy C++ 14 language support.  "
},
{
	"uri": "https://ned14.github.io/outcome/build/",
	"title": "Build and install",
	"tags": [],
	"description": "",
	"content": " Outcome v2 is feature complete, meeting the feedback from the Boost peer review in May 2017. It is an all new code base, written entirely from scratch during the month of June 2017. It has completed three months of maturation, and will shortly be sent back to Boost for a second peer review. As a result, consider this library to beta quality and subject change if a second review demands it.\nThat said, the essentials here are the same as they were in v1. Indeed most code written for v1 should be convertible to v2 without too much effort.\nUsage as a single header file Outcome v2 comes in single header file form. This is regenerated per commit. To fetch on Linux:\nwget https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On BSD and OS X:\nfetch https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On Windows, simply download the raw file from above and place it wherever it suits you.\nUsage as a git submodule Given that v2 is still under development, it is currently best used as a git submodule to your project so you can keep abreast of bug fixes. Here is how:\ngit submodule add https://github.com/ned14/outcome cd outcome git checkout develop git submodule update --init --recursive  After this you can bring Outcome into your code using:\n#include \u0026quot;outcome/include/outcome.hpp\u0026quot;  That\u0026rsquo;s it, you are ready to go. From time to time, you may wish to update to latest:\ncd outcome git pull git submodule update  Usage as a stable source tarball If you would prefer a single source tarball of the stable branch containing all the documentation, tests and sources, this can always be retrieved from:\nhttps://dedi4.nedprod.com/static/files/outcome-v2.0-source-latest.tar.xz\nThis tarball is automatically generated when Outcome fully compiles and passes all unit tests on all platforms tested by the CIs. This currently includes:\n Linux: GCC 6.3, clang 4.0 MacOS: XCode 9 Windows: VS2017   Running the unit test suite To run the unit test suite you will need cmake 3.1 or later installed.\nmkdir build cd build cmake .. cmake --build . ctest  On some cmake generators (Visual Studio, Xcode) you may need to tell cmake build a configuration like Release or Debug. Similarly, ctest needs to be told the same e.g.\nmkdir build cd build cmake .. cmake --build . --config Release ctest -C Release  Per commit, tests are run by Travis and uploaded to a CDash dashboard here.\n Modular CMake build support If you are using Outcome in a CMake project, Outcome is a \u0026ldquo;modular cmake\u0026rdquo; project using only modern cmake 3 throughout. This lets you add the Outcome directory as a cmake subdirectory with no unexpected consequence on the rest of your cmake. You will need to be using cmake 3.1 or better.\nadd_subdirectory( \u0026quot;${CMAKE_CURRENT_SOURCE_DIR}/outcome\u0026quot; # path to outcome source \u0026quot;${CMAKE_CURRENT_BINARY_DIR}/outcome\u0026quot; # your choice of where to put binaries EXCLUDE_FROM_ALL # please only lazy build outcome on demand )  Outcome\u0026rsquo;s cmake has the following useful products:\n outcome::hl (target): the Outcome header only library. Add this to any target_link_libraries() in your cmake to bring in Outcome as a header only library. This will also add to your link (via PUBLIC) any debugger visualisation support files, any system library dependencies and also force all consuming executables to be configured with a minimum of C++ 14 as Outcome requires a minimum of that. outcome_TEST_TARGETS (list): a list of targets which generate Outcome\u0026rsquo;s test suite. You can append this to your own test suite if you wish to run Outcome\u0026rsquo;s test suite along with your own.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/unchecked/inspecting/",
	"title": "Inspecting unchecked&lt;T, EC&gt;",
	"tags": [],
	"description": "",
	"content": "Suppose we will be writing function print_half that takes an integral number (however big) represented as an std::string and outputs a number which is twice smaller:\noutcome::unchecked\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text);   Type unchecked\u0026lt;void\u0026gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. Class template unchecked\u0026lt;\u0026gt; is declared with attribute [[nodiscard]], which means compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).\nThe implementation will do the following: if the integral number can be represnted by an int, we will convert to int and use its arithmetical operations. If the number is too large, we will fall back to using a custom BigInt implementation that needs to allocate memory. In the implementation we will use function convert defined in the previous section.\noutcome::unchecked\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text) { if (outcome::unchecked\u0026lt;int\u0026gt; r = convert(text)) // #1  { std::cout \u0026lt;\u0026lt; (r.value() / 2) \u0026lt;\u0026lt; std::endl; // #2  } else { if (r.error() == ConversionErrc::TooLong) // #3  { OUTCOME_TRY (i, BigInt::fromString(text)); // #4  std::cout \u0026lt;\u0026lt; i.half() \u0026lt;\u0026lt; std::endl; } else { return r.as_failure(); // #5  } } return outcome::success(); // #6 }   #1. You test if unchecked\u0026lt;\u0026gt; object represents a successful operation with contextual conversion to bool.\n#2. Function .value() extracts the successfully returned BigInt.\n#3. Function .error() allows you to inspect the error sub-object, representing information about the reason for failure.\n#4. Macro OUTCOME_TRY represents a control statement. It implies that the function call in the second argument returns a unchecked\u0026lt;\u0026gt;. It is defined as:\n/*static*/ outcome::unchecked\u0026lt;BigInt\u0026gt; BigInt::fromString(const std::string\u0026amp; s)   Our control statement means: if fromString returned failure, this same error information should be returned from print_half, even though the type of unchecked\u0026lt;\u0026gt; is different. If fromString returned success, we create variable i of type int with the value returned from fromString. If control goes to subsequent line, it means fromString succeeded and variable of type int is in scope.\n#5. In the return statement we extract the error information and use it to initialize the return value from print_half. We could have written return r.error(); instead, and it would have the same effect, but it would not work if we were using outcome\u0026lt;\u0026gt; instead of unchecked\u0026lt;\u0026gt; \u0026ndash; this will be covered later.\n#6. Function success() returns an object of type success\u0026lt;void\u0026gt; representing success. This is implicitly converted by all result and outcome types into a successful return, default constructing any T if necessary.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": "  unchecked\u0026lt;T, EC\u0026gt;  TODO: more material will be provided in time\u0026hellip; First we will need to dive into unchecked\u0026lt;\u0026gt;, checked\u0026lt;\u0026gt; and result\u0026lt;\u0026gt;.\nThen customizing result and using outcome\u0026hellip;\ngraph TD A1{\"result#lt;T, E#gt;\"} --\"Success\"-- B1[\"T value()\"] A1 --\"Failure\"-- C1[\"E error()\"] A2{\"outcome#lt;T, EC, E|P#gt;\"} --\"Success\"-- B2[\"T value()\"] A2 --\"Failure\"-- C2[\"EC error()\"] A2 -- D2((\"Either\")) D2 --\"Abort\"-- E2[\"E exception()\"] D2 --\"Payload\"-- F2[\"P payload()\"]  "
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_outcome.md/",
	"title": "outcome&lt;R, S, P&gt;",
	"tags": [],
	"description": "",
	"content": " Header file outcome.hpp #define OUTCOME_OUTCOME_HPP namespace outcome_v2_xxx { class bad_outcome_access; namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } struct no_payload_type; struct no_exception_type; namespace impl { template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers; template \u0026lt;class Base, class R, class S, class NoValuePolicy\u0026gt; class outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_failure_observers; template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class outcome_failure_observers\u0026lt;Base, R, std::error_code, std::exception_ptr, NoValuePolicy\u0026gt;; } namespace policy { template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; } template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class R, class S = std::error_code, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome; template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()==std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()!=std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); template \u0026lt;class R, class S, class P, class N\u0026gt; void swap(outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); namespace policy { template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow; } namespace impl { } } Class outcome_v2_xxx::bad_outcome_access class bad_outcome_access : public std::logic_error { public: bad_outcome_access(const char* what); }; Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\nNamespace outcome_v2_xxx::trait namespace trait { template \u0026lt;class P\u0026gt; struct is_exception_ptr; } Namespace for traits\nClass template outcome_v2_xxx::trait::is_exception_ptr [Error code interpretation policy] template \u0026lt;class P\u0026gt; struct is_exception_ptr : std::integral_constant\u0026lt;_Bool, std::is_constructible\u0026lt;std::exception_ptr, P\u0026gt;::value\u0026gt; { }; Trait for whether type P is to be considered a payload to an exception.\nStruct outcome_v2_xxx::no_payload_type struct no_payload_type { no_payload_type() = delete; }; Placeholder type to indicate there is no payload type\nStruct outcome_v2_xxx::no_exception_type struct no_exception_type { no_exception_type() = delete; }; Placeholder type to indicate there is no exception type\nClass template outcome_v2_xxx::impl::outcome_payload_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_payload_observers : public Base { public: using payload_type = P; using Base::Base; constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; constexpr payload_type\u0026amp; payload() \u0026amp;; constexpr const payload_type\u0026amp; payload() const \u0026amp;; constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; }; The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::outcome_payload_observers::assume_payload (1) constexpr payload_type\u0026amp; assume_payload() \u0026amp; noexcept; (2) constexpr const payload_type\u0026amp; assume_payload() const \u0026amp; noexcept; (3) constexpr payload_type\u0026amp;\u0026amp; assume_payload() \u0026amp;\u0026amp; noexcept; (4) constexpr const payload_type\u0026amp;\u0026amp; assume_payload() const \u0026amp;\u0026amp; noexcept; Access payload without runtime checks.\nReturns: Reference to the held payload_type according to overload.\nFunction outcome_v2_xxx::impl::outcome_payload_observers::payload (1) constexpr payload_type\u0026amp; payload() \u0026amp;; (2) constexpr const payload_type\u0026amp; payload() const \u0026amp;; (3) constexpr payload_type\u0026amp;\u0026amp; payload() \u0026amp;\u0026amp;; (4) constexpr const payload_type\u0026amp;\u0026amp; payload() const \u0026amp;\u0026amp;; Access payload with runtime checks.\nReturns: Reference to the held payload_type according to overload.\nRequires: The outcome to have an payload state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::outcome_exception_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_exception_observers : public Base { public: using exception_type = P; using Base::Base; constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; constexpr exception_type\u0026amp; exception() \u0026amp;; constexpr const exception_type\u0026amp; exception() const \u0026amp;; constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; }; The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::outcome_exception_observers::assume_exception (1) constexpr exception_type\u0026amp; assume_exception() \u0026amp; noexcept; (2) constexpr const exception_type\u0026amp; assume_exception() const \u0026amp; noexcept; (3) constexpr exception_type\u0026amp;\u0026amp; assume_exception() \u0026amp;\u0026amp; noexcept; (4) constexpr const exception_type\u0026amp;\u0026amp; assume_exception() const \u0026amp;\u0026amp; noexcept; Access exception without runtime checks.\nReturns: Reference to the held exception_type according to overload.\nFunction outcome_v2_xxx::impl::outcome_exception_observers::exception (1) constexpr exception_type\u0026amp; exception() \u0026amp;; (2) constexpr const exception_type\u0026amp; exception() const \u0026amp;; (3) constexpr exception_type\u0026amp;\u0026amp; exception() \u0026amp;\u0026amp;; (4) constexpr const exception_type\u0026amp;\u0026amp; exception() const \u0026amp;\u0026amp;; Access exception with runtime checks.\nReturns: Reference to the held exception_type according to overload.\nRequires: The outcome to have an exception state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::outcome_failure_observers template \u0026lt;class Base, class R, class S, class P, class NoValuePolicy\u0026gt; class outcome_failure_observers : public Base { public: using Base::Base; }; The failure observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\nAlias template outcome_v2_xxx::policy::default_outcome_policy [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; using default_outcome_policy = std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, S\u0026gt;\u0026amp;\u0026amp;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, error_code_throw_as_system_error_exception_rethrow\u0026lt;R, S, P\u0026gt;, //terminate//\u0026gt;; Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\nFunction template outcome_v2_xxx::hook_outcome_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is first created by conversion from one of its possible types. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type, error_type, std::pair\u0026lt;error_type, payload_type\u0026gt; or exception_type.  Function template outcome_v2_xxx::hook_outcome_copy_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is created by copying from another outcome or result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_outcome_move_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is created by moving from another outcome or result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_outcome_in_place_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_outcome_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a outcome is created by in place construction. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type, error_type, std::pair\u0026lt;error_type, payload_type\u0026gt; or exception_type.  Class template outcome_v2_xxx::outcome [outcome\u0026lt;R, S, P\u0026gt; implementation] template \u0026lt;class R, class S = std::error_code, class P = std::exception_ptr, class NoValuePolicy = policy::default_outcome_policy\u0026lt;R, S, P\u0026gt;\u0026gt; class outcome : public 'hidden' { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = S; using payload_exception_type = P; using payload_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; using exception_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; template \u0026lt;class T, class U = S, class V = P\u0026gt; using rebind = outcome\u0026lt;T, U, P\u0026gt;; using value_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;value_type, error_type\u0026gt;::value||std::is_same\u0026lt;value_type, payload_exception_type\u0026gt;::value, typename base::_value_type, value_type\u0026gt;; using error_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;error_type, value_type\u0026gt;::value||std::is_same\u0026lt;error_type, payload_exception_type\u0026gt;::value, typename base::_error_type, error_type\u0026gt;; using payload_exception_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;payload_exception_type, value_type\u0026gt;::value||std::is_same\u0026lt;payload_exception_type, error_type\u0026gt;::value, disable_in_place_payload_exception_type, payload_exception_type\u0026gt;; protected: detail::devoid\u0026lt;payload_exception_type\u0026gt; _ptr; public: template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;exception_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator==(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()==std::declval\u0026lt;V\u0026gt;())); template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator!=(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()!=std::declval\u0026lt;V\u0026gt;())); template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); void swap(outcome\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;payload_exception_type\u0026gt;::value); rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; }; Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\nParameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n P - The optional type of the payload/exception result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret types S and P when a wide observation of a not present value occurs.\n  Type alias outcome_v2_xxx::outcome::value_type using value_type = R; The success type.\nType alias outcome_v2_xxx::outcome::status_error_type using status_error_type = S; The S type configured\nType alias outcome_v2_xxx::outcome::error_type using error_type = S; The failure type.\nType alias outcome_v2_xxx::outcome::payload_exception_type using payload_exception_type = P; The P type configured.\nType alias outcome_v2_xxx::outcome::payload_type using payload_type = std::conditional_t\u0026lt;trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_payload_type, P\u0026gt;; The payload type, always no_payload_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is true.\nType alias outcome_v2_xxx::outcome::exception_type using exception_type = std::conditional_t\u0026lt;!trait::is_exception_ptr\u0026lt;P\u0026gt;::value, no_exception_type, P\u0026gt;; The exception type, always no_exception_type if trait::is_exception_ptr\u0026lt;P\u0026gt; is false.\nAlias template outcome_v2_xxx::outcome::rebind template \u0026lt;class T, class U = S, class V = P\u0026gt; using rebind = outcome\u0026lt;T, U, P\u0026gt;; Used to rebind this outcome to a different outcome type\nType alias outcome_v2_xxx::outcome::value_type_if_enabled using value_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;value_type, error_type\u0026gt;::value||std::is_same\u0026lt;value_type, payload_exception_type\u0026gt;::value, typename base::_value_type, value_type\u0026gt;; Used to disable in place type construction when value_type is ambiguous with error_type or payload_exception_type.\nType alias outcome_v2_xxx::outcome::error_type_if_enabled using error_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;error_type, value_type\u0026gt;::value||std::is_same\u0026lt;error_type, payload_exception_type\u0026gt;::value, typename base::_error_type, error_type\u0026gt;; Used to disable in place type construction when error_type is ambiguous with value_type or payload_exception_type.\nType alias outcome_v2_xxx::outcome::payload_exception_type_if_enabled using payload_exception_type_if_enabled = std::conditional_t\u0026lt;std::is_same\u0026lt;payload_exception_type, value_type\u0026gt;::value||std::is_same\u0026lt;payload_exception_type, error_type\u0026gt;::value, disable_in_place_payload_exception_type, payload_exception_type\u0026gt;; Used to disable in place type construction when payload_exception_type is ambiguous with value_type or error_type.\nFunction template outcome_v2_xxx::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful outcome.\nEffects: Initialises the outcome with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, is not constructible to exception_type and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to an errored outcome.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, is not constructible to payload_exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t, U\u0026amp;\u0026amp; u) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, U\u0026gt;::value); Converting constructor to an errored outcome + payload/exception.\nEffects: Initialises the outcome with a error_type and a payload_exception_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Type U is constructible to payload_exception_type, is not constructible to value_type.\nThrows: Any exception the construction of error_type(T) and payload_exception_type(U) might throw.\nParameters:\n t - The value from which to initialise the error_type.\n u - The value from which to initialise the payload_exception_type.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T\u0026gt; constexpr outcome(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;exception_type, T\u0026gt;::value); Converting constructor to an excepted outcome.\nEffects: Initialises the outcome with a exception_type.\nRequires: trait::is_exception_ptr\u0026lt;P\u0026gt; must be true; Type T is constructible to exception_type, is not constructible to value_type, is not constructible to status_error_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of exception_type(T) might throw.\nParameters:\n t - The value from which to initialise the exception_type.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Explicit converting copy constructor from a compatible outcome type.\nEffects: Initialises the outcome with a copy of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Implicit converting copy constructor from a compatible outcome type.\nEffects: Initialises the outcome with a copy of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Explicit converting move constructor from a compatible outcome type.\nEffects: Initialises the outcome with a move of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s value_type, error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type, V\u0026gt;::value); Implicit converting move constructor from a compatible outcome type.\nEffects: Initialises the outcome with a move of the compatible outcome.\nRequires: Both outcome\u0026rsquo;s error_type, status_type, payload_type and exception_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) or payload_exception_type(V) might throw.\nParameters:\n o - The compatible outcome.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Explicit converting copy constructor from a compatible result type.\nEffects: Initialises the outcome with a copy of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Implicit converting copy constructor from a compatible result type.\nEffects: Initialises the outcome with a copy of the compatible result.\nRequires: Both outcome\u0026rsquo;serror_type and status_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction ofstatus_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Explicit converting move constructor from a compatible result type.\nEffects: Initialises the outcome with a move of the compatible result.\nRequires: Both outcome\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T), status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class T, class U, class V\u0026gt; constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;payload_exception_type\u0026gt;::value); Implicit converting move constructor from a compatible result type.\nEffects: Initialises the outcome with a move of the compatible result.\nRequires: Both outcome\u0026rsquo;s error_type and status_type need to be constructible, or the source void. The source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) or payload_exception_type() might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of value_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n Tag type to indicate we are doing in place construction of error_type.\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: payload_exception_type is void or Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(Args...) might throw.\nParameters:\n args - Arguments with which to in place construct.  Function template outcome_v2_xxx::outcome::outcome template \u0026lt;class U, class ... Args\u0026gt; constexpr outcome(in_place_type_t\u0026lt;payload_exception_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;payload_exception_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to an unsuccessful payload/exception.\nEffects: Initialises the outcome with a payload_exception_type.\nRequires: The initializer list + Args... are constructible to payload_exception_type.\nThrows: Any exception the construction of payload_exception_type(il, Args...) might throw.\nParameters:\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Comparison operator outcome_v2_xxx::outcome::operator== template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator==(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()==std::declval\u0026lt;V\u0026gt;())); True if equal to the other outcome.\nEffects: Calls the operator== operation on each of the three stored items until one returns false.\nRequires: That the expression of calling operator== on each of the three stored items is a valid expression.\nThrows: Any exception the individual operator== operations might throw.\nParameters:\n o - The other outcome to compare to.  Comparison operator outcome_v2_xxx::outcome::operator!= template \u0026lt;class T, class U, class V, class W\u0026gt; constexpr )//\u0026gt;bool operator!=(const outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;P\u0026gt;()!=std::declval\u0026lt;V\u0026gt;())); True if not equal to the other outcome.\nEffects: Calls the operator!= operation on each of the three stored items until one returns true.\nRequires: That the expression of calling operator!= on each of the three stored items is a valid expression.\nThrows: Any exception the individual operator!= operations might throw.\nParameters:\n o - The other outcome to compare to.  Comparison operator outcome_v2_xxx::outcome::operator== template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); True if equal to the other result.\nEffects: Calls the operator== operation on each of the two stored items until one returns false.\nRequires: That the expression of calling operator== on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator== operations might throw.\nParameters:\n o - The other result to compare to.  Comparison operator outcome_v2_xxx::outcome::operator!= template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); True if not equal to the other result.\nEffects: Calls the operator!= operation on each of the two stored items until one returns true.\nRequires: That the expression of calling operator!= on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator!= operations might throw.\nParameters:\n o - The other result to compare to.  Function outcome_v2_xxx::outcome::swap void swap(outcome\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;payload_exception_type\u0026gt;::value); Swaps this result with another result\nEffects: Any R and/or S is swapped along with the metadata tracking them.\nFunction outcome_v2_xxx::outcome::as_void rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; Returns this outcome rebound to void with any errored and payload state copied.\nRequires: This outcome to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::outcome::as_void rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; Returns this outcome rebound to void with any errored and payload state moved.\nRequires: This outcome to have a failed state, else whatever assume_error() would do.\nComparison operator outcome_v2_xxx::operator== template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator==(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()==std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); True if the result is equal to the outcome\nEffects: Calls b == a.\nRequires: That the expression b == a is a valid expression.\nThrows: Any exception that b == a might throw.\nParameters:\n a - The result to compare.\n b - The outcome to compare.\n  Comparison operator outcome_v2_xxx::operator!= template \u0026lt;class T, class U, class V, class R, class S, class P, class N\u0026gt; constexpr )//\u0026gt;bool operator!=(const result\u0026lt;T, U, V\u0026gt;\u0026amp; a, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(//noexcept(std::declval\u0026lt;outcome\u0026lt;R, S, P, N\u0026gt;\u0026gt;()!=std::declval\u0026lt;result\u0026lt;T, U, V\u0026gt;\u0026gt;())); True if the result is not equal to the outcome\nEffects: Calls b != a.\nRequires: That the expression b != a is a valid expression.\nThrows: Any exception that b != a might throw.\nParameters:\n a - The result to compare.\n b - The outcome to compare.\n  Function template outcome_v2_xxx::swap template \u0026lt;class R, class S, class P, class N\u0026gt; void swap(outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); Specialise swap for outcome.\nEffects: Calls a.swap(b).\nClass template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow [Error code interpretation policy] template \u0026lt;class R, class S, class P\u0026gt; struct error_code_throw_as_system_error_exception_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If outcome does not have a value, if it has an exception it rethrows it via std::rethrow_exception(), if has an error it throws a std::system_error(error()), else it throws bad_outcome_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If outcome does not have an error, it throws bad_outcome_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have a payload, it throws bad_outcome_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error_exception_rethrow::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, it throws bad_outcome_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/unchecked/",
	"title": "unchecked&lt;T, EC&gt;",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 namespace It is recommended that you refer to entities from this Outcome 2.0 via the following namespace alias:\nnamespace outcome = OUTCOME_V2_NAMESPACE;   As patches and modifications are applied to this library, namespaces get permuted in order not to break any backward compatibility. At some point namespace outcome::v2 will be defined, and this will be the prefered namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome::v2.\nCreating unchecked\u0026lt;\u0026gt; We will define a function that converts an std::string to an int. This function can fail for a number of reasons; if it does we want to communicate the failure reason.\noutcome::unchecked\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept;   Class template unchecked\u0026lt;T, EC\u0026gt; has two template parameters. The first (T) represents the type of the object returned from the function upon success; the second (EC) is the type of object containing information about the reason for failure when the function fails. A unchecked\u0026lt;T, EC\u0026gt; object either stores a T or an EC at any given moment, and is therefore conceptually similar to variant\u0026lt;T, EC\u0026gt;. EC is defaulted to std::error_code. If both T and EC are trivially copyable, unchecked\u0026lt;T, EC\u0026gt; is also trivially copyable.\nBoth unchecked\u0026lt;T, EC\u0026gt; and checked\u0026lt;T, EC\u0026gt; are simplified typedefs for result\u0026lt;T, EC\u0026gt;, but are instances of result\u0026lt;T, EC\u0026gt;. Anything we say about unchecked\u0026lt;\u0026gt; can also be said about checked\u0026lt;T, EC\u0026gt; and result\u0026lt;T, EC\u0026gt;, unless otherwise specified.\n Now, we will define an enumeration describing different failure situations during conversion.\nenum class ConversionErrc { EmptyString = 1, // 0 is never an error  IllegalChar = 2, TooLong = 3, }; // all boilerplate necessary to plug ConversionErrc // into std::error_code framework   Assume we have plugged it into std::error_code framework, as described in this section.\nOne notable effect of such plugging is that ConversionErrc is now convertible to std::error_code. Now we can implement function convert as follows:\noutcome::unchecked\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept { if (str.empty()) return ConversionErrc::EmptyString; if (!std::all_of(str.begin(), str.end(), ::isdigit)) return ConversionErrc::IllegalChar; if (str.length() \u0026gt; 9) return ConversionErrc::TooLong; return atoi(str.c_str()); }   unchecked\u0026lt;T, EC\u0026gt; is convertible from any T2 convertible to T as well as any EC2 convertible to EC, provided that the conversion is not ambiguous. If some type X is both convertible to T and EC, conversion to unchecked\u0026lt;T, EC\u0026gt; fails to compile. In this case you need to use one of the tagged constructors:\noutcome::unchecked\u0026lt;int\u0026gt; r {outcome::in_place_type\u0026lt;std::error_code\u0026gt;, ConversionErrc::EmptyString}; outcome::unchecked\u0026lt;int\u0026gt; s {outcome::in_place_type\u0026lt;int\u0026gt;, 1};   "
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/",
	"title": "API reference",
	"tags": [],
	"description": "",
	"content": " OUTCOME_ENABLE_POSITIVE_STATUS\n OUTCOME_ERROR_FROM_EXCEPTION_HPP\n OUTCOME_IOSTREAM_SUPPORT_HPP\n OUTCOME_OUTCOME_HPP\n OUTCOME_RESULT_HPP\n OUTCOME_TRY - If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure immediately, else set *v( to the unwrapped value\n OUTCOME_TRY2\n OUTCOME_TRYV - If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately\n OUTCOME_TRYV2\n OUTCOME_TRYX - If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately, else become the unwrapped value as an expression. This makes OUTCOME_TRYX(expr) an expression which can be used exactly like the try operator in other languages.\n OUTCOME_TRY_GLUE\n OUTCOME_TRY_GLUE2\n OUTCOME_TRY_HPP\n OUTCOME_TRY_UNIQUE_NAME\n outcome_v2_xxx\n bad_outcome_access - Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn\u0026rsquo;t present.\n bad_result_access - Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\n error_from_exception(std::exception_ptr \u0026amp;\u0026amp;, std::error_code)\u0026rdquo;) - Utility function which tries to match the exception in the pointer provided to an equivalent error code. Ought to work for all standard STL types. param e The pointer to an exception to convert. If matched, on exit this is reset to a null pointer. param not_matched The error code to return if we could not match the exception. Note that a null pointer in returns a null error code.\n hook_outcome_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is first created by conversion from one of its possible types. Does nothing.\n hook_outcome_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is created by copying from another outcome or result. Does nothing.\n hook_outcome_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is created by in place construction. Does nothing.\n hook_outcome_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a outcome is created by moving from another outcome or result. Does nothing.\n hook_result_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is first created by conversion from one of its possible types. Does nothing.\n hook_result_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is created by copying from another result. Does nothing.\n hook_result_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is created by in place construction. Does nothing.\n hook_result_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U *)\u0026rdquo;) - The default instantiation hook implementation called when a result is created by moving from another result. Does nothing.\n no_error_type - Placeholder type to indicate there is no error type\n no_exception_type - Placeholder type to indicate there is no exception type\n no_payload_type - Placeholder type to indicate there is no payload type\n no_value_type - Placeholder type to indicate there is no value type\n operator!=(const result\u0026lt;T, U, V\u0026gt; \u0026amp;, const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - True if the result is not equal to the outcome\n operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Serialise an outcome\n operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Serialise a result\n operator==(const result\u0026lt;T, U, V\u0026gt; \u0026amp;, const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - True if the result is equal to the outcome\n operator\u0026gt;\u0026gt;(std::istream \u0026amp;, outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Deserialise an outcome\n operator\u0026gt;\u0026gt;(std::istream \u0026amp;, result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Deserialise a result\n outcome - Used to return from functions (i) a value and (a positive status and/or a payload) or (ii) no value and (a negative status and/or a payload). constexpr capable.\n print(const outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Debug print an outcome\n print(const result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Debug print a result\n result - Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\n swap(outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;, outcome\u0026lt;R, S, P, N\u0026gt; \u0026amp;)\u0026rdquo;) - Specialise swap for outcome.\n swap(result\u0026lt;R, S, P\u0026gt; \u0026amp;, result\u0026lt;R, S, P\u0026gt; \u0026amp;)\u0026rdquo;) - Specialise swap for result.\n try_operation_return_as(T \u0026amp;\u0026amp;)\u0026rdquo;) - Customisation point for changing what the OUTCOME_TRY macros do. This function defaults to returning std::move(v).as_void().\n  outcome_v2_xxx::impl\n outcome_exception_observers - The exception observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_exception_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n outcome_failure_observers - The failure observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_failure_observers\u0026lt;Base, R, std::error_code, std::exception_ptr, NoValuePolicy\u0026gt;\n outcome_payload_observers - The payload observers implementation of outcome\u0026lt;R, S, P\u0026gt;. Only appears separate due to standardese limitations.\n outcome_payload_observers\u0026lt;Base, R, S, void, NoValuePolicy\u0026gt;\n result_error_observers - The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n result_final - The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_storage - The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers - The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\n result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;\n select_result_impl\n  outcome_v2_xxx::policy\n default_outcome_policy - Default outcome\u0026lt;R, S, P\u0026gt; policy selector.\n default_result_policy - Default result\u0026lt;R, S\u0026gt; policy selector.\n error_code_throw_as_system_error - Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\n error_code_throw_as_system_error_exception_rethrow - Policy interpreting S as a type implementing the std::error_code contract, E as a type implementing the std::exception_ptr contract, and any wide attempt to access the successful state throws the exception_ptr if available, then the error_code wrapped into a std::system_error.\n exception_ptr_rethrow - Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\n terminate - Policy implementing any wide attempt to access the successful state as calling std::terminate\n throw_directly - Policy interpreting EC as a type to be thrown directly during wide checks.\n  outcome_v2_xxx::trait - Namespace for traits\n is_exception_ptr - Trait for whether type P is to be considered a payload to an exception.    "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/unchecked/try/",
	"title": "TRY operations",
	"tags": [],
	"description": "",
	"content": "In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRY:\nOUTCOME_TRY (i, BigInt::fromString(text));  This control statement is raughly equivalent to:\nauto\u0026amp;\u0026amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto\u0026amp;\u0026amp; i = __result.value();  Where __result is a unique name.\nAdditionally, in GCC and Clang which provide an extension to C++ known as statement expressions it is possible to use an alternative macro: OUTCOME_TRYX, which is an expression. With the above macro, the above declaration of variable i can be rewritten to:\nint i = OUTCOME_TRYX (BigInt::fromString(text));  This has an advantage that you can use it any place where you can put an expression, e.g., in \u0026ldquo;simple initialization\u0026rdquo;:\nif (int i = OUTCOME_TRYX(BigInt::fromString(text))) use_a_non_zero_int(i);  or in as a subexpression of a bigger full expression:\nint ans = OUTCOME_TRYX(BigInt::fromString(\u0026#34;1\u0026#34;)) + OUTCOME_TRYX(BigInt::fromString(\u0026#34;2\u0026#34;));  This macro makes use of a proprietary extension in GCC and clang and is not portable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\n Macro OUTCOME_TRY does two things: 1. It extracts a T from result\u0026lt;T\u0026gt; (or outcome\u0026lt;T\u0026gt;). 2. It declares a dependency between statements: If the \u0026ldquo;tried\u0026rdquo; statement fails, the next statement is not executed.\nWhen you are calling functions that return unchecked\u0026lt;void\u0026gt; the first of the two things does not make sense. You then have to use macro OUTCOME_TRYV instead. Let\u0026rsquo;s use our function print_half:\noutcome::unchecked\u0026lt;void\u0026gt; test() { OUTCOME_TRYV (print_half(\u0026#34;2\u0026#34;)); OUTCOME_TRYV (print_half(\u0026#34;X\u0026#34;)); OUTCOME_TRYV (print_half(\u0026#34;4\u0026#34;)); // will not execute  return outcome::success(); }   The first statement will succeed. The second statement will \u0026ldquo;fail\u0026rdquo;, i.e. it will return an errored unchecked. This will cause an immediate return and the subsequent statements will be skipped.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_result.md/",
	"title": "result&lt;R, S&gt;",
	"tags": [],
	"description": "",
	"content": " Header file result.hpp #define OUTCOME_RESULT_HPP #define OUTCOME_ENABLE_POSITIVE_STATUS namespace outcome_v2_xxx { class bad_result_access; struct no_value_type; struct no_error_type; namespace impl { template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage; template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_value_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers; template \u0026lt;class Base, class NoValuePolicy\u0026gt; class result_error_observers\u0026lt;Base, void, NoValuePolicy\u0026gt;; template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; using select_result_impl = result_error_observers\u0026lt;result_value_observers\u0026lt;result_storage\u0026lt;R, EC, NoValuePolicy\u0026gt;, R, NoValuePolicy\u0026gt;, EC, NoValuePolicy\u0026gt;; template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final; } namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result; template \u0026lt;class R, class S, class P\u0026gt; void swap(result\u0026lt;R, S, P\u0026gt;\u0026amp; a, result\u0026lt;R, S, P\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); } Class outcome_v2_xxx::bad_result_access class bad_result_access : public std::logic_error { public: bad_result_access(const char* what); }; Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn\u0026rsquo;t present.\nStruct outcome_v2_xxx::no_value_type struct no_value_type { no_value_type() = delete; }; Placeholder type to indicate there is no value type\nStruct outcome_v2_xxx::no_error_type struct no_error_type { no_error_type() = delete; }; Placeholder type to indicate there is no error type\nClass template outcome_v2_xxx::impl::result_storage template \u0026lt;class R, class EC, class NoValuePolicy\u0026gt; class result_storage { protected: using _value_type = std::conditional_t\u0026lt;std::is_same\u0026lt;R, EC\u0026gt;::value, disable_in_place_value_type, R\u0026gt;; using _error_type = std::conditional_t\u0026lt;std::is_same\u0026lt;R, EC\u0026gt;::value, disable_in_place_error_type, EC\u0026gt;; detail::value_storage_select_impl\u0026lt;_value_type\u0026gt; _state; detail::devoid\u0026lt;_error_type\u0026gt; _error; result_storage() = default; result_storage(const result_storage\u0026amp;) = default; result_storage(result_storage\u0026amp;\u0026amp;) = default; result_storage\u0026amp; operator=(const result_storage\u0026amp;) = default; result_storage\u0026amp; operator=(result_storage\u0026amp;\u0026amp;) = default; template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_value_type\u0026gt; _, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_value_type\u0026gt; _, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_error_type\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result_storage(in_place_type_t\u0026lt;_error_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); struct compatible_conversion_tag; template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;void, U, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, const result_storage\u0026lt;T, void, V\u0026gt;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class U, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;void, U, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_error_type, U\u0026gt;::value); template \u0026lt;class T, class V\u0026gt; constexpr result_storage(compatible_conversion_tag, result_storage\u0026lt;T, void, V\u0026gt;\u0026amp;\u0026amp; o) noexcept(std::is_nothrow_constructible\u0026lt;_value_type, T\u0026gt;::value); }; The base implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nClass template outcome_v2_xxx::impl::result_value_observers template \u0026lt;class Base, class R, class NoValuePolicy\u0026gt; class result_value_observers : public Base { public: using value_type = R; using Base::Base; constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; constexpr value_type\u0026amp; value() \u0026amp;; constexpr const value_type\u0026amp; value() const \u0026amp;; constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; }; The value observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::result_value_observers::assume_value (1) constexpr value_type\u0026amp; assume_value() \u0026amp; noexcept; (2) constexpr const value_type\u0026amp; assume_value() const \u0026amp; noexcept; (3) constexpr value_type\u0026amp;\u0026amp; assume_value() \u0026amp;\u0026amp; noexcept; (4) constexpr const value_type\u0026amp;\u0026amp; assume_value() const \u0026amp;\u0026amp; noexcept; Access value without runtime checks.\nReturns: Reference to the held value_type according to overload.\nFunction outcome_v2_xxx::impl::result_value_observers::value (1) constexpr value_type\u0026amp; value() \u0026amp;; (2) constexpr const value_type\u0026amp; value() const \u0026amp;; (3) constexpr value_type\u0026amp;\u0026amp; value() \u0026amp;\u0026amp;; (4) constexpr const value_type\u0026amp;\u0026amp; value() const \u0026amp;\u0026amp;; Access value with runtime checks.\nReturns: Reference to the held value_type according to overload.\nRequires: The result to have a successful state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::result_error_observers template \u0026lt;class Base, class EC, class NoValuePolicy\u0026gt; class result_error_observers : public Base { public: using error_type = EC; using Base::Base; constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; constexpr error_type\u0026amp; error() \u0026amp;; constexpr const error_type\u0026amp; error() const \u0026amp;; constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; }; The error observers implementation of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nFunction outcome_v2_xxx::impl::result_error_observers::assume_error (1) constexpr error_type\u0026amp; assume_error() \u0026amp; noexcept; (2) constexpr const error_type\u0026amp; assume_error() const \u0026amp; noexcept; (3) constexpr error_type\u0026amp;\u0026amp; assume_error() \u0026amp;\u0026amp; noexcept; (4) constexpr const error_type\u0026amp;\u0026amp; assume_error() const \u0026amp;\u0026amp; noexcept; Access error without runtime checks.\nReturns: Reference to the held error_type according to overload.\nFunction outcome_v2_xxx::impl::result_error_observers::error (1) constexpr error_type\u0026amp; error() \u0026amp;; (2) constexpr const error_type\u0026amp; error() const \u0026amp;; (3) constexpr error_type\u0026amp;\u0026amp; error() \u0026amp;\u0026amp;; (4) constexpr const error_type\u0026amp;\u0026amp; error() const \u0026amp;\u0026amp;; Access error with runtime checks.\nReturns: Reference to the held error_type according to overload.\nRequires: The result to have a failed state, else whatever NoValuePolicy says ought to happen.\nClass template outcome_v2_xxx::impl::result_final template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result_final : public select_result_impl\u0026lt;R, S, NoValuePolicy\u0026gt; { public: using ::base/'base::base; constexpr operator bool() const noexcept; constexpr bool has_value() const noexcept; constexpr bool has_error() const noexcept; constexpr bool has_payload() const noexcept; constexpr bool has_exception() const noexcept; constexpr bool has_failure() const noexcept; template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); }; The assembled implementation type of result\u0026lt;R, EC, NoValuePolicy\u0026gt;. Only appears separate due to standardese limitations.\nConversion operator outcome_v2_xxx::impl::result_final::operator bool constexpr operator bool() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::impl::result_final::has_value constexpr bool has_value() const noexcept; Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::impl::result_final::has_error constexpr bool has_error() const noexcept; Checks if has error.\nReturns: True if has error.\nFunction outcome_v2_xxx::impl::result_final::has_payload constexpr bool has_payload() const noexcept; Checks if has payload.\nReturns: True if has payload.\nFunction outcome_v2_xxx::impl::result_final::has_exception constexpr bool has_exception() const noexcept; Checks if has exception.\nReturns: True if has exception.\nFunction outcome_v2_xxx::impl::result_final::has_failure constexpr bool has_failure() const noexcept; Checks if has error or exception.\nReturns: True if has error or exception.\nComparison operator outcome_v2_xxx::impl::result_final::operator== template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator==(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()==std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()==std::declval\u0026lt;U\u0026gt;())); True if equal to the other result.\nEffects: Calls the operator== operation on each of the two stored items until one returns false.\nRequires: That the expression of calling operator== on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator== operations might throw.\nParameters:\n o - The other result to compare to.  Comparison operator outcome_v2_xxx::impl::result_final::operator!= template \u0026lt;class T, class U, class V, typename = decltype(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;()\u0026gt; constexpr )//\u0026gt;bool operator!=(const result_final\u0026lt;T, U, V\u0026gt;\u0026amp; o) const noexcept(//noexcept(std::declval\u0026lt;R\u0026gt;()!=std::declval\u0026lt;T\u0026gt;())//\u0026amp;\u0026amp;noexcept(std::declval\u0026lt;S\u0026gt;()!=std::declval\u0026lt;U\u0026gt;())); True if not equal to the other result.\nEffects: Calls the operator!= operation on each of the two stored items until one returns true.\nRequires: That the expression of calling operator!= on each of the two stored items is a valid expression.\nThrows: Any exception the individual operator!= operations might throw.\nParameters:\n o - The other result to compare to.  Namespace outcome_v2_xxx::policy namespace policy { template \u0026lt;class EC\u0026gt; struct throw_directly; template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error; template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow; struct terminate; template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; } Namespace for policies\nClass template outcome_v2_xxx::policy::throw_directly [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct throw_directly { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type to be thrown directly during wide checks.\nFunction template outcome_v2_xxx::policy::throw_directly::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::throw_directly::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::throw_directly::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws that error(), else it throws bad_result_access.\nFunction template outcome_v2_xxx::policy::throw_directly::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome_v2_xxx::policy::error_code_throw_as_system_error [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct error_code_throw_as_system_error { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::error_code contract and any wide attempt to access the successful state throws the error_code wrapped into a std::system_error\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, if it has an error it throws a std::system_error(error()), else it throws bad_result_access.\nFunction template outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nClass template outcome_v2_xxx::policy::exception_ptr_rethrow [Error code interpretation policy] template \u0026lt;class EC\u0026gt; struct exception_ptr_rethrow { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); }; Policy interpreting EC as a type implementing the std::exception_ptr contract and any wide attempt to access the successful state calls std::rethrow_exception().\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it rethrows that error via std::rethrow_exception(), else it throws bad_result_access.\nFunction template outcome_v2_xxx::policy::exception_ptr_rethrow::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self); Performs a wide check of state, used in the value() functions\nEffects: If result does not have a value, if it has an error it throws that error, else it throws bad_result_access.\nStruct outcome_v2_xxx::policy::terminate [Error code interpretation policy] struct terminate { template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); }; Policy implementing any wide attempt to access the successful state as calling std::terminate\nFunction template outcome_v2_xxx::policy::terminate::narrow_value_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::narrow_error_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::narrow_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_payload_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_payload() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::narrow_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl* self) noexcept; Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction template outcome_v2_xxx::policy::terminate::wide_value_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl* self); Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, calls std::terminate().\nFunction template outcome_v2_xxx::policy::terminate::wide_error_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl* self) noexcept; Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, calls std::terminate().\nFunction template outcome_v2_xxx::policy::terminate::wide_payload_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_payload_check(Impl* self); Performs a wide check of state, used in the payload() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nFunction template outcome_v2_xxx::policy::terminate::wide_exception_check template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl* self); Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, calls std::terminate().\nAlias template outcome_v2_xxx::policy::default_result_policy [Error code interpretation policy] template \u0026lt;class EC\u0026gt; using default_result_policy = std::conditional_t\u0026lt;//std::is_void\u0026lt;EC\u0026gt;::value, //terminate, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::error_code, EC\u0026gt;, error_code_throw_as_system_error\u0026lt;EC\u0026gt;, //std::conditional_t\u0026lt;//detail::is_same_or_constructible\u0026lt;std::exception_ptr, EC\u0026gt;, exception_ptr_rethrow\u0026lt;EC\u0026gt;, //throw_directly\u0026lt;EC\u0026gt;//\u0026gt;\u0026gt;\u0026gt;; Default result\u0026lt;R, S\u0026gt; policy selector.\nFunction template outcome_v2_xxx::hook_result_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is first created by conversion from one of its possible types. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type or error_type.  Function template outcome_v2_xxx::hook_result_copy_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_copy_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is created by copying from another result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_result_move_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_move_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is created by moving from another result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - The type of the source.  Function template outcome_v2_xxx::hook_result_in_place_construction template \u0026lt;class T, class U\u0026gt; constexpr void hook_result_in_place_construction(in_place_type_t\u0026lt;T\u0026gt;, U*) noexcept; The default instantiation hook implementation called when a result is created by in place construction. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters:\n T - One of value_type or error_type.  Class template outcome_v2_xxx::result [result\u0026lt;R, S\u0026gt; implementation] template \u0026lt;class R, class S, class NoValuePolicy\u0026gt; class result : public impl::result_final\u0026lt;R, S, NoValuePolicy\u0026gt; { public: //=== Member types ===// using value_type = R; using status_error_type = S; using error_type = S; using value_type_if_enabled = typename base::_value_type; using error_type_if_enabled = typename base::_error_type; template \u0026lt;class T, class U = S\u0026gt; using rebind = result\u0026lt;T, U\u0026gt;; protected: struct predicate; public: //=== Default, copy/move constructors and assignment ===// result() = delete; result(result\u0026amp;\u0026amp;) = default; result(const result\u0026amp;) = default; result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; result\u0026amp; operator=(const result\u0026amp;) = default; template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); template \u0026lt;class ErrorCondEnum\u0026gt; constexpr result(ErrorCondEnum\u0026amp;\u0026amp; t) noexcept(noexcept(error_type(make_error_code(std::forward\u0026lt;ErrorCondEnum\u0026gt;(t))))); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); void swap(result\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value); rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; }; Used to return from functions (i) a value (ii) a value and a positive status or (iii) no value and a negative status. constexpr capable.\nThis is a vocabulary type implementing P0262R0 A Class for Status and Optional Value, albeit with types Status and Value reversed in lexical order. By default S is considered to be a positive status type used to supply additional information about the successful return of a type R. If however the trait trait::status_type_is_negative\u0026lt;S\u0026gt; has been specialised to be true, then S is considered to be a negative status type used to supply information about the cause of failure to return a type R.\ntrait::status_type_is_negative\u0026lt;S\u0026gt; is already set to true for these types (you can specialise in your own types easily):\n std::error_code std::exception_ptr void  When trait::status_type_is_negative\u0026lt;S\u0026gt; is false, the default for NoValuePolicy is:\n If .status() called when there is no status_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  When trait::status_type_is_negative\u0026lt;S\u0026gt; is true, the default for NoValuePolicy is:\n If .value() called when there is no value_type but there is an error_type:   If S convertible to a std::error_code, then throw std::system_error(error()) [policy::error_code_throw_as_system_error\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S convertible to a std::exception_ptr, then std::rethrow_exception(error()) [policy::exception_ptr_rethrow\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate(). If S is void, call std::terminate() [policy::terminate\u0026lt;S\u0026gt;] If S is none of the above, then someone has enabled the negative status type trait but did not specify a custom policy. We therefore simply throw error() [policy::throw_directly\u0026lt;S\u0026gt;] if C++ exceptions are enabled, else call std::terminate.   If .error() called when there is no error_type:   throw bad_result_access() if C++ exceptions are enabled, else call std::terminate().  Parameters:\n R - The optional type of the successful result (use void to disable).\n S - The optional type of the status result (use void to disable). Must be either void or DefaultConstructible.\n NoValuePolicy - Policy on how to interpret type S when a wide observation of a not present value occurs.\n  Type alias outcome_v2_xxx::result::value_type using value_type = R; The success type.\nType alias outcome_v2_xxx::result::status_error_type using status_error_type = S; The S type configured\nType alias outcome_v2_xxx::result::error_type using error_type = S; The failure type.\nType alias outcome_v2_xxx::result::value_type_if_enabled using value_type_if_enabled = typename base::_value_type; Used to disable in place type construction when value_type and error_type are ambiguous.\nType alias outcome_v2_xxx::result::error_type_if_enabled using error_type_if_enabled = typename base::_error_type; Used to disable in place type construction when value_type and error_type are ambiguous.\nAlias template outcome_v2_xxx::result::rebind template \u0026lt;class T, class U = S\u0026gt; using rebind = result\u0026lt;T, U\u0026gt;; Used to rebind this result to a different result type.\nStruct outcome_v2_xxx::result::predicate struct predicate { using base = 'hidden'; }; Requirement predicates for result.\nDefault constructor outcome_v2_xxx::result::result result() = delete; Default construction is not permitted.\nMove constructor outcome_v2_xxx::result::result result(result\u0026amp;\u0026amp;) = default; Move construction available if value_type and status_error_type implement it.\nCopy constructor outcome_v2_xxx::result::result result(const result\u0026amp;) = default; Copy construction available if value_type and status_error_type implement it.\nAssignment operator outcome_v2_xxx::result::operator= result\u0026amp; operator=(result\u0026amp;\u0026amp;) = default; Move assignment available if value_type and status_error_type implement it.\nAssignment operator outcome_v2_xxx::result::operator= result\u0026amp; operator=(const result\u0026amp;) = default; Copy assignment available if value_type and status_error_type implement it.\nFunction template outcome_v2_xxx::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value); Converting constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: Type T is constructible to value_type, is not constructible to status_error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters:\n t - The value from which to initialise the value_type.  Function template outcome_v2_xxx::result::result template \u0026lt;class T\u0026gt; constexpr result(T\u0026amp;\u0026amp; t) noexcept(std::is_nothrow_constructible\u0026lt;error_type, T\u0026gt;::value); Converting constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; Type T is constructible to error_type, is not constructible to value_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters:\n t - The value from which to initialise the error_type.  Function template outcome_v2_xxx::result::result template \u0026lt;class ErrorCondEnum\u0026gt; constexpr result(ErrorCondEnum\u0026amp;\u0026amp; t) noexcept(noexcept(error_type(make_error_code(std::forward\u0026lt;ErrorCondEnum\u0026gt;(t))))); Special error condition converting constructor to a failure result.\nEffects: Initialises the result with a error_type constructed via make_error_code(t).\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; std::is_error_condition_enum\u0026lt;ErrorCondEnum\u0026gt; must be true, ErrorCondEnum is not constructible to value_type nor error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Finally, the expression error_type(make_error_code(ErrorCondEnum())) must be valid.\nThrows: Any exception the construction of error_type(make_error_code(t)) might throw.\nParameters:\n t - The error condition from which to initialise the error_type.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Explicit converting copy constructor from a compatible result type.\nEffects: Initialises the result with a copy of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source status_error_type can be void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(const result\u0026lt;T, U, V\u0026gt;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Implicit converting copy constructor from a compatible result type.\nEffects: Initialises the result with a copy of the compatible result.\nRequires: Both result\u0026rsquo;s error_type and status_type need to be constructible, and the source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::explicit_compatible_conversion_tag/'explicit_compatible_conversion_tag = explicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;value_type, T\u0026gt;::value\u0026amp;\u0026amp;std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Explicit converting move constructor from a compatible result type.\nEffects: Initialises the result with a move of the compatible result.\nRequires: Both result\u0026rsquo;s value_type, error_type and status_type need to be constructible, or the source status_error_type can be void. The source value_type cannot be void.\nThrows: Any exception the construction of value_type(T) and status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class T, class U, class V\u0026gt; constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o, ::implicit_compatible_conversion_tag/'implicit_compatible_conversion_tag = implicit_compatible_conversion_tag()) noexcept(std::is_nothrow_constructible\u0026lt;status_error_type, U\u0026gt;::value); Implicit converting move constructor from a compatible result type.\nEffects: Initialises the result with a move of the compatible result.\nRequires: Both result\u0026rsquo;s error_type and status_type need to be constructible, and the source value_type must be void.\nThrows: Any exception the construction of status_error_type(U) might throw.\nParameters:\n o - The compatible result.  Function template outcome_v2_xxx::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters:\n args - Arguments with which to in place construct.  Function template outcome_v2_xxx::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;value_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters:\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function template outcome_v2_xxx::result::result template \u0026lt;class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters:\n args - Arguments with which to in place construct.  Function template outcome_v2_xxx::result::result template \u0026lt;class U, class ... Args\u0026gt; constexpr result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; il, Args\u0026amp;\u0026amp;... args) noexcept(std::is_nothrow_constructible\u0026lt;error_type, std::initializer_list\u0026lt;U\u0026gt;, Args...\u0026gt;::value); Inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: trait::status_type_is_negative\u0026lt;EC\u0026gt; must be true; The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters:\n il - An initializer list with which to in place construct.\n args - Arguments with which to in place construct.\n  Function outcome_v2_xxx::result::swap void swap(result\u0026amp; o) noexcept(detail::is_nothrow_swappable\u0026lt;value_type\u0026gt;::value//\u0026amp;\u0026amp;detail::is_nothrow_swappable\u0026lt;status_error_type\u0026gt;::value); Swaps this result with another result\nEffects: Any R and/or S is swapped along with the metadata tracking them.\nFunction outcome_v2_xxx::result::as_void rebind\u0026lt;void\u0026gt; as_void() const \u0026amp;; Returns this result rebound to void with any errored state copied.\nRequires: This result to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::result::as_void rebind\u0026lt;void\u0026gt; as_void() \u0026amp;\u0026amp;; Returns this result rebound to void with any errored state moved.\nRequires: This result to have a failed state, else whatever assume_error() would do.\nFunction template outcome_v2_xxx::swap template \u0026lt;class R, class S, class P\u0026gt; void swap(result\u0026lt;R, S, P\u0026gt;\u0026amp; a, result\u0026lt;R, S, P\u0026gt;\u0026amp; b) noexcept(noexcept(a.swap(b))); Specialise swap for result.\nEffects: Calls a.swap(b).\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/unchecked/error_code/",
	"title": "Custom error codes",
	"tags": [],
	"description": "",
	"content": "This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].\nSuppose you want to report all reasons for failure in conveting an std::string to a non-negative int. The list is:\n EmptyString \u0026ndash; the input string is empty, IllegalChar \u0026ndash; input contains characters that are not digits, TooLong \u0026ndash; input represents a number, but this number would not fit into a variable of type int.  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; // for string printing#include \u0026lt;system_error\u0026gt; // bring in std::error_code et al // This is the custom error code enum enum class ConversionErrc { EmptyString = 1, // 0 is never an error  IllegalChar = 2, TooLong = 3, }; namespace std { // Tell the C++ 11 STL metaprogramming that enum MathError::valid_errors  // is registered with the standard error code system  template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;ConversionErrc\u0026gt; : std::true_type { }; } namespace detail { // Define a custom error code category derived from std::error_category  class ConversionErrc_category : public std::error_category { public: // Return a short descriptive name for the category  virtual const char *name() const noexcept override final { return \u0026#34;ConversionError\u0026#34;; } // Return what each enum means in text  virtual std::string message(int c) const override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return \u0026#34;converting empty string\u0026#34;; case ConversionErrc::IllegalChar: return \u0026#34;got non-digit chatr when converting to a number\u0026#34;; case ConversionErrc::TooLong: return \u0026#34;the number would not fit into memory\u0026#34;; default: return \u0026#34;unknown\u0026#34;; } } // OPTIONAL: Allow generic error conditions to be compared to me  virtual std::error_condition default_error_condition(int c) const noexcept override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::IllegalChar: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::TooLong: return make_error_condition(std::errc::result_out_of_range); default: // I have no mapping for this code  return std::error_condition(c, *this); } } }; } // Declare a global function returning a static instance of the custom category extern const detail::ConversionErrc_category \u0026amp;ConversionErrc_category() { static detail::ConversionErrc_category c; return c; } // Overload the global make_error_code() free function with our // custom enum. It will be found via ADL by the compiler if needed. inline std::error_code make_error_code(ConversionErrc e) { return {static_cast\u0026lt;int\u0026gt;(e), ConversionErrc_category()}; } int main(void) { // Note that we can now supply ConversionErrc directly to error_code  std::error_code ec = ConversionErrc::IllegalChar; std::cout \u0026lt;\u0026lt; \u0026#34;ConversionErrc::IllegalChar is printed by std::error_code as \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; \u0026#34; with explanatory message \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; std::endl; // We can compare ConversionErrc containing error codes to generic conditions  std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::invalid_argument = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::invalid_argument) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::result_out_of_range = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::result_out_of_range) \u0026lt;\u0026lt; std::endl; return 0; }   This might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:\n Any code which can speak std::error_code can now work with errors from your code, AND without being recompiled. std::system_error can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception and back out again without losing information. std::error_code knows how to print itself, and will print your custom error code without extra work from you. As usually you\u0026rsquo;d need to define a print routine for any custom error code you\u0026rsquo;d write anyway, there is actually very little extra boilerplate here. If you implement the default_error_condition() override, you can allow code exclusively written to understand std::errc alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.  [1]: The only documentation I\u0026rsquo;m aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:\n http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html  "
},
{
	"uri": "https://ned14.github.io/outcome/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": " Why is implicit default construction disabled? This was one of the more interesting points of discussion during the peer review of Outcome v1. v1 had a formal empty state. This came with many advantages, but it was not felt to be STL idiomatic as std::optional\u0026lt;result\u0026lt;T\u0026gt;\u0026gt; is what was meant, so v2 has eliminated any legal possibility of being empty.\nThe expected\u0026lt;T, E\u0026gt; proposal of that time (May 2017) did permit default construction if its T type allowed default construction. This was specifically done to make expected\u0026lt;T, E\u0026gt; more useful in STL containers as one can say resize a vector without having to supply an expected\u0026lt;T, E\u0026gt; instance to fill the new items with. However there was some unease with that design choice, because it may cause programmers to use some type T whose default constructed state is overloaded with additional meaning, typically \u0026ldquo;to be filled\u0026rdquo; i.e. a de facto empty state via choosing a magic value.\nFor the v2 redesign, the various arguments during the v1 review were considered. Unlike expected\u0026lt;T, E\u0026gt; which is intended to be a general purpose Either monad vocabulary type, Outcome\u0026rsquo;s types are meant primarily for returning success or failure from functions. The API should therefore encourage the programmer to not overload the successful type with additional meaning of \u0026ldquo;to be filled\u0026rdquo; e.g. result\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;. The decision was therefore taken to disable implicit default construction, but still permit explicit default construction by making the programmer spell out their intention with extra typing.\nTo therefore explicitly default construct a result\u0026lt;T\u0026gt; or outcome\u0026lt;T\u0026gt;, use one of these forms as is the most appropriate for the use case:\n Construct with just in_place_type\u0026lt;T\u0026gt; e.g. result\u0026lt;T\u0026gt;(in_place_type\u0026lt;T\u0026gt;). Construct via success() e.g. outcome\u0026lt;T\u0026gt;(success()). Construct from a void form e.g. result\u0026lt;T\u0026gt;(result\u0026lt;void\u0026gt;(in_place_type\u0026lt;void\u0026gt;)).  How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Not far, in fact after the Boost.Outcome peer review in May 2017, Expected moved much closer to Outcome. Here are the remaining differences which represent the divergence of consensus opinion between the Boost peer review and WG21 on the proper design for this object:\n checked\u0026lt;T, E\u0026gt; has no default constructor. Expected has a default constructor if T has a default constructor. checked\u0026lt;T, E\u0026gt; uses the same constructor design as std::variant\u0026lt;...\u0026gt;. Expected uses the constructor design of std::optional\u0026lt;T\u0026gt;. checked\u0026lt;T, E\u0026gt; cannot be modified after construction except by assignment. Expected provides an .emplace() modifier. checked\u0026lt;T, E\u0026gt; permits implicit construction from both T and E when unambiguous. Expected permits implicit construction from T alone. checked\u0026lt;T, E\u0026gt; does not permit T and E to be the same, and becomes annoying to use if they are constructible into one another (implicit construction self-disables). Expected permits T and E to be the same. checked\u0026lt;T, E\u0026gt; throws bad_result_access_with\u0026lt;E\u0026gt; instead of Expected\u0026rsquo;s bad_expected_access\u0026lt;E\u0026gt;. checked\u0026lt;T, E\u0026gt; models std::variant\u0026lt;...\u0026gt;. Expected models std::optional\u0026lt;T\u0026gt;. Thus:  checked\u0026lt;T, E\u0026gt; does not provide operator*() nor operator-\u0026gt; checked\u0026lt;T, E\u0026gt; .error() is wide (i.e. throws on incorrect use) like .value(). Expected\u0026rsquo;s .error() is narrow (UB on incorrect use). (checked\u0026lt;T, E\u0026gt; provides .assume_value() and .assume_error() for narrow (UB causing) observers)  checked\u0026lt;T, E\u0026gt; uses success\u0026lt;T\u0026gt; and failure\u0026lt;E\u0026gt; type sugars for disambiguation. Expected uses unexpected\u0026lt;E\u0026gt; only. checked\u0026lt;T, E\u0026gt; requires E to be default constructible.  In fact, the two are sufficiently close in design that a highly conforming expected\u0026lt;T, E\u0026gt; can be implemented by wrapping up checked\u0026lt;T, E\u0026gt; with the missing functionality:\n/* Here is a fairly conforming implementation of P0323R3 `expected\u0026lt;T, E\u0026gt;` using `checked\u0026lt;T, E\u0026gt;`. It passes the reference test suite for P0323R3 at https://github.com/viboes/std-make/blob/master/test/expected/expected_pass.cpp with modifications only to move the test much closer to the P0323R3 Expected, as the reference test suite is for a much older proposed Expected. Known differences from P0323R3 in this implementation: - `T` and `E` cannot be the same type. - `E` must be default constructible. - No variant storage is implemented (note the Expected proposal does not actually require this). */ namespace detail { template \u0026lt;class T, class E\u0026gt; using expected_result = OUTCOME_V2_NAMESPACE::checked\u0026lt;T, E\u0026gt;; template \u0026lt;class T, class E\u0026gt; struct enable_default_constructor : public expected_result\u0026lt;T, E\u0026gt; { using base = expected_result\u0026lt;T, E\u0026gt;; using base::base; constexpr enable_default_constructor() : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;} { } }; template \u0026lt;class T, class E\u0026gt; using select_expected_base = std::conditional_t\u0026lt;std::is_default_constructible\u0026lt;T\u0026gt;::value, enable_default_constructor\u0026lt;T, E\u0026gt;, expected_result\u0026lt;T, E\u0026gt;\u0026gt;; } template \u0026lt;class T, class E\u0026gt; class expected : public detail::select_expected_base\u0026lt;T, E\u0026gt; { static_assert(!std::is_same\u0026lt;T, E\u0026gt;::value, \u0026#34;T and E cannot be the same in this expected implementation\u0026#34;); using base = detail::select_expected_base\u0026lt;T, E\u0026gt;; public: // Inherit base\u0026#39;s constructors  using base::base; expected() = default; // Expected takes in_place not in_place_type  template \u0026lt;class... Args\u0026gt; constexpr explicit expected(in_place_t /*unused*/, Args \u0026amp;\u0026amp;... args) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...} { } // Expected always accepts a T even if ambiguous  OUTCOME_TEMPLATE(class U) OUTCOME_TREQUIRES(OUTCOME_TPRED(std::is_constructible\u0026lt;T, U\u0026gt;::value)) constexpr expected(U \u0026amp;\u0026amp;v) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;U\u0026gt;(v)} { } // Expected has an emplace() modifier  template \u0026lt;class... Args\u0026gt; void emplace(Args \u0026amp;\u0026amp;... args) { *static_cast\u0026lt;base *\u0026gt;(this) = base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...}; } // Expected has a narrow operator* and operator-\u0026gt;  constexpr const T \u0026amp;operator*() const \u0026amp; { return base::assume_value(); } constexpr T \u0026amp;operator*() \u0026amp; { return base::assume_value(); } constexpr const T \u0026amp;\u0026amp;operator*() const \u0026amp;\u0026amp; { return base::assume_value(); } constexpr T \u0026amp;\u0026amp;operator*() \u0026amp;\u0026amp; { return base::assume_value(); } constexpr const T *operator-\u0026gt;() const { return \u0026amp;base::assume_value(); } constexpr T *operator-\u0026gt;() { return \u0026amp;base::assume_value(); } // Expected has a narrow error() observer  constexpr const E \u0026amp;error() const \u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp; { return base::assume_error(); } constexpr const E \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp;\u0026amp; { return base::assume_error(); } }; template \u0026lt;class E\u0026gt; class expected\u0026lt;void, E\u0026gt; : public OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt; { using base = OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt;; public: // Inherit base constructors  using base::base; // Expected has a narrow operator* and operator-\u0026gt;  constexpr void operator*() const { base::assume_value(); } constexpr void operator-\u0026gt;() const { base::assume_value(); } }; template \u0026lt;class E\u0026gt; using unexpected = OUTCOME_V2_NAMESPACE::failure_type\u0026lt;E\u0026gt;; template \u0026lt;class E\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(E \u0026amp;\u0026amp;arg) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;E\u0026gt;(arg)); } template \u0026lt;class E, class... Args\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(Args \u0026amp;\u0026amp;... args) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...); } template \u0026lt;class E\u0026gt; using bad_expected_access = OUTCOME_V2_NAMESPACE::bad_result_access_with\u0026lt;E\u0026gt;;   "
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_try.md/",
	"title": "Try operations",
	"tags": [],
	"description": "",
	"content": " Header file try.hpp #define OUTCOME_TRY_HPP #define OUTCOME_TRY_GLUE2(x, y) #define OUTCOME_TRY_GLUE(x, y) #define OUTCOME_TRY_UNIQUE_NAME #define OUTCOME_TRYV2(unique, m) #define OUTCOME_TRY2(unique, v, m) #define OUTCOME_TRYV(m) #define OUTCOME_TRYX(m) #define OUTCOME_TRY(v, m) namespace outcome_v2_xxx { template \u0026lt;class T\u0026gt; typename T::template rebind\u0026lt;void\u0026gt; try_operation_return_as(T\u0026amp;\u0026amp; v); } Macro OUTCOME_TRYV #define OUTCOME_TRYV(m) If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately\nMacro OUTCOME_TRYX #define OUTCOME_TRYX(m) If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure state immediately, else become the unwrapped value as an expression. This makes OUTCOME_TRYX(expr) an expression which can be used exactly like the try operator in other languages.\nportable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\nMacro OUTCOME_TRY #define OUTCOME_TRY(v, m) If the outcome returned by expression m is not valued, propagate any failure by immediately returning that failure immediately, else set *v( to the unwrapped value\nFunction template outcome_v2_xxx::try_operation_return_as template \u0026lt;class T\u0026gt; typename T::template rebind\u0026lt;void\u0026gt; try_operation_return_as(T\u0026amp;\u0026amp; v); Customisation point for changing what the OUTCOME_TRY macros do. This function defaults to returning std::move(v).as_void().\nEffects: Extracts any state apart from value into a void rebound equivalent.\nRequires: The input value to have a .as_void() member function, and a rebind member template alias.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/doc_utils.md/",
	"title": "Utilities",
	"tags": [],
	"description": "",
	"content": " Header file utils.hpp #define OUTCOME_ERROR_FROM_EXCEPTION_HPP namespace outcome_v2_xxx { std::error_code error_from_exception(std::exception_ptr\u0026amp;\u0026amp; ep, std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept; } Function outcome_v2_xxx::error_from_exception std::error_code error_from_exception(std::exception_ptr\u0026amp;\u0026amp; ep, std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept; Utility function which tries to match the exception in the pointer provided to an equivalent error code. Ought to work for all standard STL types. param e The pointer to an exception to convert. If matched, on exit this is reset to a null pointer. param not_matched The error code to return if we could not match the exception. Note that a null pointer in returns a null error code.\neffects Rethrows the exception in the pointer, and via a long sequence of catch clauses attempts to match the equivalent error code. If a match is found, the pointer is reset to null. If a match is not found, not_matched is returned instead and the pointer is left unmodified.\n"
},
{
	"uri": "https://ned14.github.io/outcome/api-reference/iostream_support.md/",
	"title": "iostream support",
	"tags": [],
	"description": "",
	"content": " Header file iostream_support.hpp #define OUTCOME_IOSTREAM_SUPPORT_HPP namespace outcome_v2_xxx { template \u0026lt;class R, class S, class P\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, result\u0026lt;R, S, P\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P\u0026gt; std::string print(const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P, class N\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P, class N\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); template \u0026lt;class R, class S, class P, class N\u0026gt; std::string print(const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); } Input operator outcome_v2_xxx::operator\u0026gt;\u0026gt; template \u0026lt;class R, class S, class P\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, result\u0026lt;R, S, P\u0026gt;\u0026amp; v); Deserialise a result\nOutput operator outcome_v2_xxx::operator\u0026lt;\u0026lt; template \u0026lt;class R, class S, class P\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); Serialise a result\nFunction template outcome_v2_xxx::print template \u0026lt;class R, class S, class P\u0026gt; std::string print(const result\u0026lt;R, S, P\u0026gt;\u0026amp; v); Debug print a result\nInput operator outcome_v2_xxx::operator\u0026gt;\u0026gt; template \u0026lt;class R, class S, class P, class N\u0026gt; std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); Deserialise an outcome\nOutput operator outcome_v2_xxx::operator\u0026lt;\u0026lt; template \u0026lt;class R, class S, class P, class N\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; s, const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); Serialise an outcome\nFunction template outcome_v2_xxx::print template \u0026lt;class R, class S, class P, class N\u0026gt; std::string print(const outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp; v); Debug print an outcome\n"
},
{
	"uri": "https://ned14.github.io/outcome/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\ngantt dateFormat YYYY-MM title History of the Outcome library Outcome v1: done, des1, 2014-06,2017-05 Boost peer review of v1: done, des2, after des1, 30d Outcome v2: active, des3, after des2, 365d section Events Separated from AFIO v1: crit, done, 2014-06,2d Boost.Expected added: crit, done, 2014-10,2d Boost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,2d Non-allocating future-promise implementation dropped: crit, done, 2016-05,2d C++ 11 support dropped: crit, done, 2016-06,2d Implemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,2d Outcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,2d Boost.Outcome generated by script from Outcome repo: crit, done, 2017-10,2d  The genesis of Outcome v1 The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of metaprogramming being replaced with cleaner variable templates in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;.\nA period of maturation then followed by porting a large existing codebase using Outcome v1 to v2, and writing a significant amount of new code using v2 to test it for unanticipated surprises and bugs. Quite a few corner cases were found and fixed. At the end of September 2017, Outcome v2 was deemed to be \u0026ldquo;mature\u0026rdquo; and a script generated \u0026ldquo;Boost edition\u0026rdquo; made available. All that remained before it was ready for a second Boost peer review was the documentation.\n"
},
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 663 commits   @akrzemi1 9 commits   @jenkins-nedprod 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 library Outcome is a C++14 library for reporting and handling function failures. It can be used as a substitute for, or a complement to, exception handling mechanism.\nOne use case is for contexts where using C++ exception handling is unsuitable for different reasons:\n The high relative cost of throwing and catching a C++ exception, Making some or all control paths explicitly detailed to aid code correctness auditing, as opposed to having hidden control paths caused by exceptions potentially thrown from any place, Company\u0026rsquo;s policy to compile with exceptions disabled, Maintaining a code base that was never designed with exception-safety in mind, Parts of the programs/frameworks that themselves implement exception handling and cannot afford to use exceptions, like propagating failure reports across threads, tasks, fibers\u0026hellip;  Another use case is to replace \u0026lsquo;dual\u0026rsquo; interfaces, like ones in Boost.Filesystem, where almost each function comes in two overloads, one throwing an exception, the other populating an error_code output argument. With Outcome, you can have only one function returning a composite return type, and it is through using this return value that you decide whether to handle failures locally, or to launch stack unwinding.\nOutcome can also be used to plug components that potentially throw exceptions into parts of the program that are not exception-safe while retaining all information from the thrown exception objects.\nSample usage Function that may need to report failure needs to reflect that in its return type:\nauto read_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;;   Function read_int_from_file will either return an int or information about the reason for failure.\nIt is possible to inspect the returned state manualy:\nif (auto rslt = read_int_from_file(\u0026#34;config.cfg\u0026#34;)) use_int(rslt.value()); else report_error(rslt.error()); // returns std::error_code   But most of the time you would inspect the object indirectly through a dedicated control statement. An implementation of read_int_from_file that has to (1) open the file, (2) read raw data to a buffer, and (3) interpret it as int, using the following three functions\nauto open_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;Handle\u0026gt;; auto read_data(Handle\u0026amp; h) noexcept -\u0026gt; outcome::result\u0026lt;Buffer\u0026gt;; auto parse(const Buffer\u0026amp; b) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;;   will look like this:\nauto read_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt; { OUTCOME_TRY(handle, open_file(path)); // decltype(handle) == Handle  OUTCOME_TRY(buffer, read_data(handle)); // decltype(buffer) == Buffer  OUTCOME_TRY(val, parse(buffer)); // decltype(val) == int  return val; }   Each occurance of OUTCOME_TRY is a control statement. If the returned result\u0026lt;T\u0026gt; contains an error information, the function is immediately returned with result\u0026lt;U\u0026gt; containing the same error information; otherwise object of type T is move-constructed on the stack.\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library is expected to pass a second Boost peer review expected for the end of 2017.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]