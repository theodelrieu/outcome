[
{
	"uri": "https://ned14.github.io/outcome/requirements/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Outcome is a header only C++ 14 library known to work on these compiler-platform combinations or better:\n clang 4.0.1 (LLVM) [FreeBSD, Linux, OS X] GCC 6.3 [Linux] Visual Studio 2017 [Windows] XCode 9 [MacOS]  It is worth turning on C++ 17 if you can, there are many usability and performance improvements. If your compiler implements the Concepts TS, it is worth turning support on. Support is automatically detected and used.\nPartially working compilers:\n GCC 5.4.1 is highly usable so long as you don\u0026rsquo;t use Outcome in a constexpr evaluation context. clang 3.5 - 3.9 can compile varying degrees of the test suite, the problem is lack of complete and unbuggy C++ 14 language support.  "
},
{
	"uri": "https://ned14.github.io/outcome/build/",
	"title": "Build and install",
	"tags": [],
	"description": "",
	"content": " Outcome v2 is feature complete, meeting the feedback from the Boost peer review in May 2017. It is an all new code base, written entirely from scratch during the month of June 2017. It has completed three months of maturation, and will shortly be sent back to Boost for a second peer review. As a result, consider this library to beta quality and subject change if a second review demands it.\nThat said, the essentials here are the same as they were in v1. Indeed most code written for v1 should be convertible to v2 without too much effort.\nUsage as a single header file Outcome v2 comes in single header file form. This is regenerated per commit. To fetch on Linux:\nwget https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On BSD and OS X:\nfetch https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On Windows, simply download the raw file from above and place it wherever it suits you.\nUsage as a git submodule Given that v2 is still under development, it is currently best used as a git submodule to your project so you can keep abreast of bug fixes. Here is how:\ngit submodule add https://github.com/ned14/outcome cd outcome git checkout develop git submodule update --init --recursive  After this you can bring Outcome into your code using:\n#include \u0026quot;outcome/include/outcome.hpp\u0026quot;  That\u0026rsquo;s it, you are ready to go. From time to time, you may wish to update to latest:\ncd outcome git pull git submodule update  Usage as a stable source tarball If you would prefer a single source tarball of the stable branch containing all the documentation, tests and sources, this can always be retrieved from:\nhttps://dedi4.nedprod.com/static/files/outcome-v2.0-source-latest.tar.xz\nThis tarball is automatically generated when Outcome fully compiles and passes all unit tests on all platforms tested by the CIs. This currently includes:\n Linux: GCC 6.3, clang 4.0 MacOS: XCode 9 Windows: VS2017   Running the unit test suite To run the unit test suite you will need cmake 3.1 or later installed.\nmkdir build cd build cmake .. cmake --build . ctest  On some cmake generators (Visual Studio, Xcode) you may need to tell cmake build a configuration like Release or Debug. Similarly, ctest needs to be told the same e.g.\nmkdir build cd build cmake .. cmake --build . --config Release ctest -C Release  Per commit, tests are run by Travis and uploaded to a CDash dashboard here.\n Modular CMake build support If you are using Outcome in a CMake project, Outcome is a \u0026ldquo;modular cmake\u0026rdquo; project using only modern cmake 3 throughout. This lets you add the Outcome directory as a cmake subdirectory with no unexpected consequence on the rest of your cmake. You will need to be using cmake 3.1 or better.\nadd_subdirectory( \u0026quot;${CMAKE_CURRENT_SOURCE_DIR}/outcome\u0026quot; # path to outcome source \u0026quot;${CMAKE_CURRENT_BINARY_DIR}/outcome\u0026quot; # your choice of where to put binaries EXCLUDE_FROM_ALL # please only lazy build outcome on demand )  Outcome\u0026rsquo;s cmake has the following useful products:\n outcome::hl (target): the Outcome header only library. Add this to any target_link_libraries() in your cmake to bring in Outcome as a header only library. This will also add to your link (via PUBLIC) any debugger visualisation support files, any system library dependencies and also force all consuming executables to be configured with a minimum of C++ 14 as Outcome requires a minimum of that. outcome_TEST_TARGETS (list): a list of targets which generate Outcome\u0026rsquo;s test suite. You can append this to your own test suite if you wish to run Outcome\u0026rsquo;s test suite along with your own.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": "  result\u0026lt;T, EC\u0026gt; outcome\u0026lt;T, EC, EP\u0026gt;  TODO: more material will be provided in time\u0026hellip; First we will need to dive into result\u0026lt;\u0026gt;.\nThen customizing result and using outcome\u0026hellip;\ngraph TD A1{\"result#lt;T, E#gt;\"} --\"Success\"-- B1[\"T value()\"] A1 --\"Failure\"-- C1[\"E error()\"] A2{\"outcome#lt;T, EC, E|P#gt;\"} --\"Success\"-- B2[\"T value()\"] A2 --\"Failure\"-- C2[\"EC error()\"] A2 -- D2((\"Either\")) D2 --\"Abort\"-- E2[\"E exception()\"] D2 --\"Payload\"-- F2[\"P payload()\"]  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/",
	"title": "result&lt;T, EC&gt;",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 namespace It is recommended that you refer to entities from this Outcome 2.0 via the following namespace alias:\nnamespace outcome = OUTCOME_V2_NAMESPACE;  View this code on Github As patches and modifications are applied to this library, namespaces get permuted in order not to break any backward compatibility. At some point namespace outcome::v2 will be defined, and this will be the prefered namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome::v2.\nCreating result\u0026lt;\u0026gt; We will define a function that converts an std::string to an int. This function can fail for a number of reasons; if it does we want to communicate the failure reason.\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept;  View this code on Github Class template result\u0026lt;T, EC\u0026gt; has two template parameters. The first (T) represents the type of the object returned from the function upon success; the second (EC) is the type of object containing information about the reason for failure when the function fails. A result\u0026lt;T, EC\u0026gt; object either stores a T or an EC at any given moment, and is therefore conceptually similar to variant\u0026lt;T, EC\u0026gt;. EC is defaulted to std::error_code. If both T and EC are trivially copyable, result\u0026lt;T, EC\u0026gt; is also trivially copyable.\nNow, we will define an enumeration describing different failure situations during conversion.\nenum class ConversionErrc { EmptyString = 1, // 0 is never an error  IllegalChar = 2, TooLong = 3, }; // all boilerplate necessary to plug ConversionErrc // into std::error_code framework  View this code on Github Assume we have plugged it into std::error_code framework, as described in this section.\nOne notable effect of such plugging is that ConversionErrc is now convertible to std::error_code. Now we can implement function convert as follows:\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept { if (str.empty()) return ConversionErrc::EmptyString; if (!std::all_of(str.begin(), str.end(), ::isdigit)) return ConversionErrc::IllegalChar; if (str.length() \u0026gt; 9) return ConversionErrc::TooLong; return atoi(str.c_str()); }  View this code on Github result\u0026lt;T, EC\u0026gt; is convertible from any T2 convertible to T as well as any EC2 convertible to EC, provided that the conversion is not ambiguous. If some type X is both convertible to T and EC, conversion to result\u0026lt;T, EC\u0026gt; fails to compile. In this case you need to use one of the tagged constructors:\noutcome::result\u0026lt;int\u0026gt; r {outcome::in_place_type\u0026lt;std::error_code\u0026gt;, ConversionErrc::EmptyString}; outcome::result\u0026lt;int\u0026gt; s {outcome::in_place_type\u0026lt;int\u0026gt;, 1};  View this code on Github Or use helper factory functions:\noutcome::result\u0026lt;int\u0026gt; r = outcome::failure(ConversionErrc::EmptyString); outcome::result\u0026lt;int\u0026gt; s = outcome::success(1);  View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/inspecting/",
	"title": "Inspecting result&lt;T, EC&gt;",
	"tags": [],
	"description": "",
	"content": "Suppose we will be writing function print_half that takes an integral number (however big) represented as an std::string and outputs a number which is twice smaller:\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text);  View this code on Github Type result\u0026lt;void\u0026gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. Class template result\u0026lt;\u0026gt; is declared with attribute [[nodiscard]], which means compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).\nThe implementation will do the following: if the integral number can be represnted by an int, we will convert to int and use its arithmetical operations. If the number is too large, we will fall back to using a custom BigInt implementation that needs to allocate memory. In the implementation we will use function convert defined in the previous section.\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text) { if (outcome::result\u0026lt;int\u0026gt; r = convert(text)) // #1  { std::cout \u0026lt;\u0026lt; (r.value() / 2) \u0026lt;\u0026lt; std::endl; // #2  } else { if (r.error() == ConversionErrc::TooLong) // #3  { OUTCOME_TRY (i, BigInt::fromString(text)); // #4  std::cout \u0026lt;\u0026lt; i.half() \u0026lt;\u0026lt; std::endl; } else { return r.as_failure(); // #5  } } return outcome::success(); // #6 }  View this code on Github #1. You test if result\u0026lt;\u0026gt; object represents a successful operation with contextual conversion to bool.\n#2. Function .value() extracts the successfully returned BigInt.\n#3. Function .error() allows you to inspect the error sub-object, representing information about the reason for failure.\n#4. Macro OUTCOME_TRY represents a control statement. It implies that the function call in the second argument returns a result\u0026lt;\u0026gt;. It is defined as:\n/*static*/ outcome::result\u0026lt;BigInt\u0026gt; BigInt::fromString(const std::string\u0026amp; s)  View this code on Github Our control statement means: if fromString returned failure, this same error information should be returned from print_half, even though the type of result\u0026lt;\u0026gt; is different. If fromString returned success, we create variable i of type int with the value returned from fromString. If control goes to subsequent line, it means fromString succeeded and variable of type int is in scope.\n#5. In the return statement we extract the error information and use it to initialize the return value from print_half. We could have written return r.error(); instead, and it would have the same effect, but it would not work if we were using outcome\u0026lt;\u0026gt; instead of result\u0026lt;\u0026gt; \u0026ndash; this will be covered later.\n#6. Function success() returns an object of type success\u0026lt;void\u0026gt; representing success. This is implicitly converted by all result and outcome types into a successful return, default constructing any T if necessary.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/outcome/",
	"title": "outcome&lt;T, EC, EP&gt;",
	"tags": [],
	"description": "",
	"content": " outcome Type outcome\u0026lt;T, EC, EP\u0026gt; can store either a T or an EC or an EP. The first parameter (T) represents a value returned from functions upon success. Both EC and EP represent the reason for function failure when function fails. Conceptually, outcome\u0026lt;T, EC, EP\u0026gt; can be thought of as variant\u0026lt;T, EC, EP\u0026gt; or variant\u0026lt;T, variant\u0026lt;EC, EP\u0026gt;\u0026gt;, or result\u0026lt;variant\u0026lt;EC, EP\u0026gt;\u0026gt;. EC defaults to std::error_code and EP defaults to std::exception_ptr. THe distinction is made into two types, EC and EP for the following reasosns:\n The interface: EC is inspected in a different way that EP. Performance: handling of EC is optimized for POD types. Interoperability with result\u0026lt;T, EC\u0026gt;: like converisons.  outcome\u0026lt;T, EC, EP\u0026gt; is useful for transporting exceptions across layers of the program that was never designed with exception_ptr`safety in mind.\nConsider a program consisting of three layers:\nLayer3 ^ | Layer2NX ^ | Layer1  The highest-level layer, Layer3, uses exceptions for signalling failures. The middle layer, Layer2NX, was not designed with exception safety in mind and function need to return information about failures in return value. But down in the implementation details, in Layer1, another library is used that again throws exceptions. The goal is to be able to transfer an exception thrown in Layer1 through Layer2, which is not exception-safe, and be able to rethrow it in Layer3.\nIn Layer1 we have a throwing function:\nnamespace Layer1 { auto f() -\u0026gt; int; // may throw }  View this code on Github In Layer2NX we cannot use exceptions, so its function g uses result\u0026lt;\u0026gt; to report failures:\nnamespace Layer2NX { auto g() noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt; ; }  View this code on Github There is another function in Layer2NX that has to use both Layer1::f and Layer2NX::g. It cannot use Layer1::f directly as the later may throw an exception, so it has to wrap it into a non-throwing function Layer2NX::f:\nnamespace Layer2NX { auto f() noexcept -\u0026gt; outcome::outcome\u0026lt;int\u0026gt; try { return Layer1::f(); } catch (...) { return std::current_exception(); } }  View this code on Github This wrapper funciton returns type outcome\u0026lt;int\u0026gt;. If an exception is thrown, it is caught by an std::exception_ptr. This std::exception_ptr is converted to outcome\u0026lt;T\u0026gt; upon return. outcome\u0026lt;T, EC, EP\u0026gt; is convertible from T, EC and EP as long as such conversion is not ambiguous.\nNow function Layer2NX::fun can be implemented with non-throwing Layer2NX::f and Layer2NX::g:\nnamespace Layer2NX { auto fun() noexcept -\u0026gt; outcome::outcome\u0026lt;double\u0026gt; { Resource* resource = new (std::nothrow) Resource; if (!resource) return std::errc::not_enough_memory; outcome::outcome\u0026lt;int\u0026gt; fr = Layer2NX::f(); if (!fr) { delete resource; return fr.as_failure(); // #1  } double ans = resource-\u0026gt;use(fr.value()); outcome::result\u0026lt;int\u0026gt; gr = Layer2NX::g(); if (!gr) { delete resource; return gr.as_failure(); // #2  } ans += resource-\u0026gt;use(gr.value()); delete resource; return ans; } }  View this code on Github In the example above, manually deleting resource represents a non-exception-safe code. Typically it is not recommended to manually delete memory because it is hard to get right in case exceptions are thrown. But when exceptions are known not to be thrown (e.g., when they are disabled) this recommendation is weakened.\n#1. When we want to forward (return up) the outcome\u0026lt;\u0026gt; object representing failure, we use function as_failure() it returns type failure_type\u0026lt;EC, EP\u0026gt; which is convertible to any to outcome\u0026lt;T, EC, EP\u0026gt; for any T.\n#2. We can similarly forward a failure from result\u0026lt;\u0026gt; again by calling as_failure(), the result will be converted to outcome\u0026lt;\u0026gt; preserving the information about function failure.\nIf the management of resource is automated through RAII, even with exceptions disabled, you can use OUTCOME_TRY to make the code more concise:\nnamespace Layer2NX { auto fun2() noexcept -\u0026gt; outcome::outcome\u0026lt;double\u0026gt; { std::unique_ptr\u0026lt;Resource\u0026gt; resource {new (std::nothrow) Resource}; if (!resource) return std::errc::not_enough_memory; OUTCOME_TRY (fr, Layer2NX::f()); double ans = resource-\u0026gt;use(fr); OUTCOME_TRY (gr, Layer2NX::g()); ans += resource-\u0026gt;use(gr); return ans; } }  View this code on Github Statement OUTCOME_TRY works for outcome and you can also use it to return failure from result\u0026lt;\u0026gt; as outcome\u0026lt;\u0026gt; as shown in the second OUTCOME_TRY.\n"
},
{
	"uri": "https://ned14.github.io/outcome/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": " Why is implicit default construction disabled? This was one of the more interesting points of discussion during the peer review of Outcome v1. v1 had a formal empty state. This came with many advantages, but it was not felt to be STL idiomatic as std::optional\u0026lt;result\u0026lt;T\u0026gt;\u0026gt; is what was meant, so v2 has eliminated any legal possibility of being empty.\nThe expected\u0026lt;T, E\u0026gt; proposal of that time (May 2017) did permit default construction if its T type allowed default construction. This was specifically done to make expected\u0026lt;T, E\u0026gt; more useful in STL containers as one can say resize a vector without having to supply an expected\u0026lt;T, E\u0026gt; instance to fill the new items with. However there was some unease with that design choice, because it may cause programmers to use some type T whose default constructed state is overloaded with additional meaning, typically \u0026ldquo;to be filled\u0026rdquo; i.e. a de facto empty state via choosing a magic value.\nFor the v2 redesign, the various arguments during the v1 review were considered. Unlike expected\u0026lt;T, E\u0026gt; which is intended to be a general purpose Either monad vocabulary type, Outcome\u0026rsquo;s types are meant primarily for returning success or failure from functions. The API should therefore encourage the programmer to not overload the successful type with additional meaning of \u0026ldquo;to be filled\u0026rdquo; e.g. result\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;. The decision was therefore taken to disable implicit default construction, but still permit explicit default construction by making the programmer spell out their intention with extra typing.\nTo therefore explicitly default construct a result\u0026lt;T\u0026gt; or outcome\u0026lt;T\u0026gt;, use one of these forms as is the most appropriate for the use case:\n Construct with just in_place_type\u0026lt;T\u0026gt; e.g. result\u0026lt;T\u0026gt;(in_place_type\u0026lt;T\u0026gt;). Construct via success() e.g. outcome\u0026lt;T\u0026gt;(success()). Construct from a void form e.g. result\u0026lt;T\u0026gt;(result\u0026lt;void\u0026gt;(in_place_type\u0026lt;void\u0026gt;)).  How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Not far, in fact after the Boost.Outcome peer review in May 2017, Expected moved much closer to Outcome. Here are the remaining differences which represent the divergence of consensus opinion between the Boost peer review and WG21 on the proper design for this object:\n checked\u0026lt;T, E\u0026gt; has no default constructor. Expected has a default constructor if T has a default constructor. checked\u0026lt;T, E\u0026gt; uses the same constructor design as std::variant\u0026lt;...\u0026gt;. Expected uses the constructor design of std::optional\u0026lt;T\u0026gt;. checked\u0026lt;T, E\u0026gt; cannot be modified after construction except by assignment. Expected provides an .emplace() modifier. checked\u0026lt;T, E\u0026gt; permits implicit construction from both T and E when unambiguous. Expected permits implicit construction from T alone. checked\u0026lt;T, E\u0026gt; does not permit T and E to be the same, and becomes annoying to use if they are constructible into one another (implicit construction self-disables). Expected permits T and E to be the same. checked\u0026lt;T, E\u0026gt; throws bad_result_access_with\u0026lt;E\u0026gt; instead of Expected\u0026rsquo;s bad_expected_access\u0026lt;E\u0026gt;. checked\u0026lt;T, E\u0026gt; models std::variant\u0026lt;...\u0026gt;. Expected models std::optional\u0026lt;T\u0026gt;. Thus:  checked\u0026lt;T, E\u0026gt; does not provide operator*() nor operator-\u0026gt; checked\u0026lt;T, E\u0026gt; .error() is wide (i.e. throws on incorrect use) like .value(). Expected\u0026rsquo;s .error() is narrow (UB on incorrect use). (checked\u0026lt;T, E\u0026gt; provides .assume_value() and .assume_error() for narrow (UB causing) observers)  checked\u0026lt;T, E\u0026gt; uses success\u0026lt;T\u0026gt; and failure\u0026lt;E\u0026gt; type sugars for disambiguation. Expected uses unexpected\u0026lt;E\u0026gt; only. checked\u0026lt;T, E\u0026gt; requires E to be default constructible. checked\u0026lt;T, E\u0026gt; defaults E to std::error_code. Expected does not default E.  In fact, the two are sufficiently close in design that a highly conforming expected\u0026lt;T, E\u0026gt; can be implemented by wrapping up checked\u0026lt;T, E\u0026gt; with the differing functionality:\n/* Here is a fairly conforming implementation of P0323R3 `expected\u0026lt;T, E\u0026gt;` using `checked\u0026lt;T, E\u0026gt;`. It passes the reference test suite for P0323R3 at https://github.com/viboes/std-make/blob/master/test/expected/expected_pass.cpp with modifications only to move the test much closer to the P0323R3 Expected, as the reference test suite is for a much older proposed Expected. Known differences from P0323R3 in this implementation: - `T` and `E` cannot be the same type. - `E` must be default constructible. - No variant storage is implemented (note the Expected proposal does not actually require this). */ namespace detail { template \u0026lt;class T, class E\u0026gt; using expected_result = OUTCOME_V2_NAMESPACE::checked\u0026lt;T, E\u0026gt;; template \u0026lt;class T, class E\u0026gt; struct enable_default_constructor : public expected_result\u0026lt;T, E\u0026gt; { using base = expected_result\u0026lt;T, E\u0026gt;; using base::base; constexpr enable_default_constructor() : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;} { } }; template \u0026lt;class T, class E\u0026gt; using select_expected_base = std::conditional_t\u0026lt;std::is_default_constructible\u0026lt;T\u0026gt;::value, enable_default_constructor\u0026lt;T, E\u0026gt;, expected_result\u0026lt;T, E\u0026gt;\u0026gt;; } template \u0026lt;class T, class E\u0026gt; class expected : public detail::select_expected_base\u0026lt;T, E\u0026gt; { static_assert(!std::is_same\u0026lt;T, E\u0026gt;::value, \u0026#34;T and E cannot be the same in this expected implementation\u0026#34;); using base = detail::select_expected_base\u0026lt;T, E\u0026gt;; public: // Inherit base\u0026#39;s constructors  using base::base; expected() = default; // Expected takes in_place not in_place_type  template \u0026lt;class... Args\u0026gt; constexpr explicit expected(in_place_t /*unused*/, Args \u0026amp;\u0026amp;... args) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...} { } // Expected always accepts a T even if ambiguous  OUTCOME_TEMPLATE(class U) OUTCOME_TREQUIRES(OUTCOME_TPRED(std::is_constructible\u0026lt;T, U\u0026gt;::value)) constexpr expected(U \u0026amp;\u0026amp;v) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;U\u0026gt;(v)} { } // Expected has an emplace() modifier  template \u0026lt;class... Args\u0026gt; void emplace(Args \u0026amp;\u0026amp;... args) { *static_cast\u0026lt;base *\u0026gt;(this) = base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...}; } // Expected has a narrow operator* and operator-\u0026gt;  constexpr const T \u0026amp;operator*() const \u0026amp; { return base::assume_value(); } constexpr T \u0026amp;operator*() \u0026amp; { return base::assume_value(); } constexpr const T \u0026amp;\u0026amp;operator*() const \u0026amp;\u0026amp; { return base::assume_value(); } constexpr T \u0026amp;\u0026amp;operator*() \u0026amp;\u0026amp; { return base::assume_value(); } constexpr const T *operator-\u0026gt;() const { return \u0026amp;base::assume_value(); } constexpr T *operator-\u0026gt;() { return \u0026amp;base::assume_value(); } // Expected has a narrow error() observer  constexpr const E \u0026amp;error() const \u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp; { return base::assume_error(); } constexpr const E \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp;\u0026amp; { return base::assume_error(); } }; template \u0026lt;class E\u0026gt; class expected\u0026lt;void, E\u0026gt; : public OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt; { using base = OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt;; public: // Inherit base constructors  using base::base; // Expected has a narrow operator* and operator-\u0026gt;  constexpr void operator*() const { base::assume_value(); } constexpr void operator-\u0026gt;() const { base::assume_value(); } }; template \u0026lt;class E\u0026gt; using unexpected = OUTCOME_V2_NAMESPACE::failure_type\u0026lt;E\u0026gt;; template \u0026lt;class E\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(E \u0026amp;\u0026amp;arg) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;E\u0026gt;(arg)); } template \u0026lt;class E, class... Args\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(Args \u0026amp;\u0026amp;... args) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...); } template \u0026lt;class E\u0026gt; using bad_expected_access = OUTCOME_V2_NAMESPACE::bad_result_access_with\u0026lt;E\u0026gt;;  View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/outcome/inspecting/",
	"title": "Inspecting outcome&lt;T, EC, EP&gt;",
	"tags": [],
	"description": "",
	"content": "Continuing with the previous example, in Layer3 we obtain an outcome\u0026lt;double\u0026gt; which may store a double or an std::error_code or an std::exception_ptr. Layer3 uses exceptions to indicate failure, so we want to turn a failed result into an exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_codes:\nnamespace Layer3 { auto run() -\u0026gt; double // may throw  { if (outcome::outcome\u0026lt;double\u0026gt; o = Layer2NX::fun()) return o.value(); else if (o.has_exception()) std::rethrow_exception(o.exception()); else throw std::system_error{o.error()}; } }  View this code on Github Function has_exception checks if it is EP (std::exception_ptr) that is stored, function exception accesses it. Similarly, function error accesses the EC (std::error_code) if it is stored. outcome\u0026lt;\u0026gt; has also function has_failure to check if either EC or EP is being stored. In fact, this pattern of \u0026ldquo;unpacking\u0026rdquo; outcome\u0026lt;\u0026gt; is so common that it has been implemented inside function value, so function Layer3::run could be written as:\nreturn Layer2NX::fun().value(); "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/try/",
	"title": "TRY operations",
	"tags": [],
	"description": "",
	"content": "In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRY:\nOUTCOME_TRY (i, BigInt::fromString(text));  This control statement is raughly equivalent to:\nauto\u0026amp;\u0026amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto\u0026amp;\u0026amp; i = __result.value();  Where __result is a unique name.\nAdditionally, in GCC and Clang which provide an extension to C++ known as statement expressions it is possible to use an alternative macro: OUTCOME_TRYX, which is an expression. With the above macro, the above declaration of variable i can be rewritten to:\nint i = OUTCOME_TRYX (BigInt::fromString(text));  This has an advantage that you can use it any place where you can put an expression, e.g., in \u0026ldquo;simple initialization\u0026rdquo;:\nif (int i = OUTCOME_TRYX(BigInt::fromString(text))) use_a_non_zero_int(i);  or in as a subexpression of a bigger full expression:\nint ans = OUTCOME_TRYX(BigInt::fromString(\u0026#34;1\u0026#34;)) + OUTCOME_TRYX(BigInt::fromString(\u0026#34;2\u0026#34;));  This macro makes use of a proprietary extension in GCC and clang and is not portable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\n Macro OUTCOME_TRY does two things: 1. It extracts a T from result\u0026lt;T\u0026gt; (or outcome\u0026lt;T\u0026gt;). 2. It declares a dependency between statements: If the \u0026ldquo;tried\u0026rdquo; statement fails, the next statement is not executed.\nWhen you are calling functions that return result\u0026lt;void\u0026gt; the first of the two things does not make sense. You then have to use macro OUTCOME_TRYV instead. Let\u0026rsquo;s use our function print_half:\noutcome::result\u0026lt;void\u0026gt; test() { OUTCOME_TRYV (print_half(\u0026#34;2\u0026#34;)); OUTCOME_TRYV (print_half(\u0026#34;X\u0026#34;)); OUTCOME_TRYV (print_half(\u0026#34;4\u0026#34;)); // will not execute  return outcome::success(); }  View this code on Github The first statement will succeed. The second statement will \u0026ldquo;fail\u0026rdquo;, i.e. it will return an errored result. This will cause an immediate return and the subsequent statements will be skipped.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/error_code/",
	"title": "Custom error codes",
	"tags": [],
	"description": "",
	"content": "This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].\nSuppose you want to report all reasons for failure in conveting an std::string to a non-negative int. The list is:\n EmptyString \u0026ndash; the input string is empty, IllegalChar \u0026ndash; input contains characters that are not digits, TooLong \u0026ndash; input represents a number, but this number would not fit into a variable of type int.  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; // for string printing#include \u0026lt;system_error\u0026gt; // bring in std::error_code et al // This is the custom error code enum enum class ConversionErrc { EmptyString = 1, // 0 is never an error  IllegalChar = 2, TooLong = 3, }; namespace std { // Tell the C++ 11 STL metaprogramming that enum MathError::valid_errors  // is registered with the standard error code system  template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;ConversionErrc\u0026gt; : std::true_type { }; } namespace detail { // Define a custom error code category derived from std::error_category  class ConversionErrc_category : public std::error_category { public: // Return a short descriptive name for the category  virtual const char *name() const noexcept override final { return \u0026#34;ConversionError\u0026#34;; } // Return what each enum means in text  virtual std::string message(int c) const override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return \u0026#34;converting empty string\u0026#34;; case ConversionErrc::IllegalChar: return \u0026#34;got non-digit chatr when converting to a number\u0026#34;; case ConversionErrc::TooLong: return \u0026#34;the number would not fit into memory\u0026#34;; default: return \u0026#34;unknown\u0026#34;; } } // OPTIONAL: Allow generic error conditions to be compared to me  virtual std::error_condition default_error_condition(int c) const noexcept override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::IllegalChar: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::TooLong: return make_error_condition(std::errc::result_out_of_range); default: // I have no mapping for this code  return std::error_condition(c, *this); } } }; } // Declare a global function returning a static instance of the custom category extern const detail::ConversionErrc_category \u0026amp;ConversionErrc_category() { static detail::ConversionErrc_category c; return c; } // Overload the global make_error_code() free function with our // custom enum. It will be found via ADL by the compiler if needed. inline std::error_code make_error_code(ConversionErrc e) { return {static_cast\u0026lt;int\u0026gt;(e), ConversionErrc_category()}; } int main(void) { // Note that we can now supply ConversionErrc directly to error_code  std::error_code ec = ConversionErrc::IllegalChar; std::cout \u0026lt;\u0026lt; \u0026#34;ConversionErrc::IllegalChar is printed by std::error_code as \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; \u0026#34; with explanatory message \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; std::endl; // We can compare ConversionErrc containing error codes to generic conditions  std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::invalid_argument = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::invalid_argument) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::result_out_of_range = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::result_out_of_range) \u0026lt;\u0026lt; std::endl; return 0; }  View this code on Github This might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:\n Any code which can speak std::error_code can now work with errors from your code, AND without being recompiled. std::system_error can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception and back out again without losing information. std::error_code knows how to print itself, and will print your custom error code without extra work from you. As usually you\u0026rsquo;d need to define a print routine for any custom error code you\u0026rsquo;d write anyway, there is actually very little extra boilerplate here. If you implement the default_error_condition() override, you can allow code exclusively written to understand std::errc alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.  [1]: The only documentation I\u0026rsquo;m aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:\n http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html  "
},
{
	"uri": "https://ned14.github.io/outcome/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\ngantt dateFormat YYYY-MM title History of the Outcome library Outcome v1: done, des1, 2014-06,2017-05 Boost peer review of v1: done, des2, after des1, 30d Outcome v2: active, des3, after des2, 365d section Events Separated from AFIO v1: crit, done, 2014-06,2d Boost.Expected added: crit, done, 2014-10,2d Boost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,2d Non-allocating future-promise implementation dropped: crit, done, 2016-05,2d C++ 11 support dropped: crit, done, 2016-06,2d Implemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,2d Outcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,2d Boost.Outcome generated by script from Outcome repo: crit, done, 2017-10,2d  The genesis of Outcome v1 The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of metaprogramming being replaced with cleaner variable templates in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;.\nA period of maturation then followed by porting a large existing codebase using Outcome v1 to v2, and writing a significant amount of new code using v2 to test it for unanticipated surprises and bugs. Quite a few corner cases were found and fixed. At the end of September 2017, Outcome v2 was deemed to be \u0026ldquo;mature\u0026rdquo; and a script generated \u0026ldquo;Boost edition\u0026rdquo; made available. All that remained before it was ready for a second Boost peer review was the documentation.\n"
},
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }  This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 library Outcome is a C++14 library for reporting and handling function failures. It can be used as a substitute for, or a complement to, exception handling mechanism.\nOne use case is for contexts where using C++ exception handling is unsuitable for different reasons:\n The high relative cost of throwing and catching a C++ exception, Making some or all control paths explicitly detailed to aid code correctness auditing, as opposed to having hidden control paths caused by exceptions potentially thrown from any place, Company\u0026rsquo;s policy to compile with exceptions disabled, Maintaining a code base that was never designed with exception-safety in mind, Parts of the programs/frameworks that themselves implement exception handling and cannot afford to use exceptions, like propagating failure reports across threads, tasks, fibers\u0026hellip;  Another use case is to replace \u0026lsquo;dual\u0026rsquo; interfaces, like ones in Boost.Filesystem, where almost each function comes in two overloads, one throwing an exception, the other populating an error_code output argument. With Outcome, you can have only one function returning a composite return type, and it is through using this return value that you decide whether to handle failures locally, or to launch stack unwinding.\nOutcome can also be used to plug components that potentially throw exceptions into parts of the program that are not exception-safe while retaining all information from the thrown exception objects.\nSample usage Function that may need to report failure needs to reflect that in its return type:\nauto read_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;;  View this code on Github Function read_int_from_file will either return an int or information about the reason for failure.\nIt is possible to inspect the returned state manualy:\nif (auto rslt = read_int_from_file(\u0026#34;config.cfg\u0026#34;)) use_int(rslt.value()); else report_error(rslt.error()); // returns std::error_code  View this code on Github But most of the time you would inspect the object indirectly through a dedicated control statement. An implementation of read_int_from_file that has to (1) open the file, (2) read raw data to a buffer, and (3) interpret it as int, using the following three functions\nauto open_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;Handle\u0026gt;; auto read_data(Handle\u0026amp; h) noexcept -\u0026gt; outcome::result\u0026lt;Buffer\u0026gt;; auto parse(const Buffer\u0026amp; b) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;;  View this code on Github will look like this:\nauto read_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt; { OUTCOME_TRY(handle, open_file(path)); // decltype(handle) == Handle  OUTCOME_TRY(buffer, read_data(handle)); // decltype(buffer) == Buffer  OUTCOME_TRY(val, parse(buffer)); // decltype(val) == int  return val; }  View this code on Github Each occurance of OUTCOME_TRY is a control statement. If the returned result\u0026lt;T\u0026gt; contains an error information, the function is immediately returned with result\u0026lt;U\u0026gt; containing the same error information; otherwise object of type T is move-constructed on the stack.\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library is expected to pass a second Boost peer review expected for the end of 2017.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]