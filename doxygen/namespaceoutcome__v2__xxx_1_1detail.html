<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Outcome: outcome_v2_xxx::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Outcome
   &#160;<span id="projectnumber">2.0 beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceoutcome__v2__xxx_1_1detail.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">outcome_v2_xxx::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceoutcome__v2__xxx_1_1detail_1_1__is__nothrow__swappable"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail_1_1__is__nothrow__swappable.html">_is_nothrow_swappable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1__is__same__or__constructible.html">_is_same_or_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1__is__same__or__constructible_3_01_t_00_01_t_01_4.html">_is_same_or_constructible&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1__is__same__or__constructible_3_01_t_00_01void_01_4.html">_is_same_or_constructible&lt; T, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1__is__same__or__constructible_3_01void_00_01void_01_4.html">_is_same_or_constructible&lt; void, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1empty__type.html">empty_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__failure__type.html">is_failure_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__failure__type_3_01failure__type_3_01_e_c_00_01_e_00_01e__is__exception__ptr_01_4_01_4.html">is_failure_type&lt; failure_type&lt; EC, E, e_is_exception_ptr &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__in__place__type__t.html">is_in_place_type_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__in__place__type__t_3_01in__place__type__t_3_01_u_01_4_01_4.html">is_in_place_type_t&lt; in_place_type_t&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__result.html">is_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__result_3_01result_3_01_r_00_01_s_00_01_t_01_4_01_4.html">is_result&lt; result&lt; R, S, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__success__type.html">is_success_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1is__success__type_3_01success__type_3_01_t_01_4_01_4.html">is_success_type&lt; success_type&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__exception__observers.html">outcome_exception_observers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception observers implementation of <code>outcome&lt;R, S, P&gt;</code>. Only appears separate due to standardese limitations.  <a href="classoutcome__v2__xxx_1_1detail_1_1outcome__exception__observers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__exception__observers_3_01_base_00_01_r_00_01_s_00_01void_00_01_no_value_policy_01_4.html">outcome_exception_observers&lt; Base, R, S, void, NoValuePolicy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__failure__observers.html">outcome_failure_observers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The failure observers implementation of <code>outcome&lt;R, S, P&gt;</code>. Only appears separate due to standardese limitations.  <a href="classoutcome__v2__xxx_1_1detail_1_1outcome__failure__observers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__payload__observers.html">outcome_payload_observers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The payload observers implementation of <code>outcome&lt;R, S, P&gt;</code>.  <a href="classoutcome__v2__xxx_1_1detail_1_1outcome__payload__observers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__payload__observers_3_01_base_00_01_r_00_01_s_00_01void_00_01_no_value_policy_01_4.html">outcome_payload_observers&lt; Base, R, S, void, NoValuePolicy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1outcome__predicates.html">outcome_predicates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1print__payload__exception.html">print_payload_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1print__payload__exception_3_01true_01_4.html">print_payload_exception&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__error__observers.html">result_error_observers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error observers implementation of <code>result&lt;R, EC, NoValuePolicy&gt;</code>.  <a href="classoutcome__v2__xxx_1_1detail_1_1result__error__observers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__error__observers_3_01_base_00_01void_00_01_no_value_policy_01_4.html">result_error_observers&lt; Base, void, NoValuePolicy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The assembled implementation type of <code>result&lt;R, EC, NoValuePolicy&gt;</code>.  <a href="classoutcome__v2__xxx_1_1detail_1_1result__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1result__predicates.html">result_predicates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__storage.html">result_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base implementation type of <code>result&lt;R, EC, NoValuePolicy&gt;</code>.  <a href="classoutcome__v2__xxx_1_1detail_1_1result__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__value__observers.html">result_value_observers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value observers implementation of <code>result&lt;R, EC, NoValuePolicy&gt;</code>.  <a href="classoutcome__v2__xxx_1_1detail_1_1result__value__observers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__value__observers_3_01_base_00_01void_00_01_no_value_policy_01_4.html">result_value_observers&lt; Base, void, NoValuePolicy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__assignment.html">value_storage_delete_copy_assignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__constructor.html">value_storage_delete_copy_constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__move__assignment.html">value_storage_delete_move_assignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__move__constructor.html">value_storage_delete_move_constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial.html">value_storage_nontrivial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial__copy__assignment.html">value_storage_nontrivial_copy_assignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial__move__assignment.html">value_storage_nontrivial_move_assignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1void__type.html">void_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a80d582ee6958238c92b5d246a7e8c87e"><td class="memTemplParams" colspan="2">template&lt;class R , class EC , class NoValuePolicy &gt; </td></tr>
<tr class="memitem:a80d582ee6958238c92b5d246a7e8c87e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a80d582ee6958238c92b5d246a7e8c87e">select_result_impl</a> = <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__error__observers.html">result_error_observers</a>&lt; <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__value__observers.html">result_value_observers</a>&lt; <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__storage.html">result_storage</a>&lt; R, EC, NoValuePolicy &gt;, R, NoValuePolicy &gt;, EC, NoValuePolicy &gt;</td></tr>
<tr class="separator:a80d582ee6958238c92b5d246a7e8c87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa938646ec2783f32e04eb97b65be4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a50aa938646ec2783f32e04eb97b65be4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a50aa938646ec2783f32e04eb97b65be4">is_nothrow_swappable</a> = <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1__is__nothrow__swappable_1_1is__nothrow__swappable.html">_is_nothrow_swappable::is_nothrow_swappable</a>&lt; T &gt;</td></tr>
<tr class="separator:a50aa938646ec2783f32e04eb97b65be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757056d8571ee8c90f71c1dad7dc1972"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a757056d8571ee8c90f71c1dad7dc1972"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a> = std::conditional_t&lt; std::is_void&lt; T &gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1void__type.html">void_type</a>, T &gt;</td></tr>
<tr class="separator:a757056d8571ee8c90f71c1dad7dc1972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29d920102ef903d21a70739819dd60d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ac29d920102ef903d21a70739819dd60d">status_bitfield_type</a> = uint32_t</td></tr>
<tr class="separator:ac29d920102ef903d21a70739819dd60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f02f9f1a51c29619fc7c7edbb9c8d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abe8f02f9f1a51c29619fc7c7edbb9c8d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#abe8f02f9f1a51c29619fc7c7edbb9c8d">value_storage_select_trivality</a> = std::conditional_t&lt; std::is_trivially_copyable&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; T &gt; &gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; T &gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial.html">value_storage_nontrivial</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:abe8f02f9f1a51c29619fc7c7edbb9c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e4563e0b111a0ff99ba632291bc69b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51e4563e0b111a0ff99ba632291bc69b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a51e4563e0b111a0ff99ba632291bc69b">value_storage_select_move_constructor</a> = std::conditional_t&lt; std::is_move_constructible&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; T &gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#abe8f02f9f1a51c29619fc7c7edbb9c8d">value_storage_select_trivality</a>&lt; T &gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__move__constructor.html">value_storage_delete_move_constructor</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#abe8f02f9f1a51c29619fc7c7edbb9c8d">value_storage_select_trivality</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="separator:a51e4563e0b111a0ff99ba632291bc69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8f3438b12021061d0d2e88bc218ae1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a8f3438b12021061d0d2e88bc218ae1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">value_storage_select_copy_constructor</a> = std::conditional_t&lt; std::is_copy_constructible&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; T &gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a51e4563e0b111a0ff99ba632291bc69b">value_storage_select_move_constructor</a>&lt; T &gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__constructor.html">value_storage_delete_copy_constructor</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a51e4563e0b111a0ff99ba632291bc69b">value_storage_select_move_constructor</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="separator:a9a8f3438b12021061d0d2e88bc218ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b45a04e0528eb7984016cd6a5718f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a60b45a04e0528eb7984016cd6a5718f9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">value_storage_select_move_assignment</a> = std::conditional_t&lt; std::is_trivially_move_assignable&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; T &gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">value_storage_select_copy_constructor</a>&lt; T &gt;, std::conditional_t&lt; std::is_move_assignable&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; T &gt; &gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial__move__assignment.html">value_storage_nontrivial_move_assignment</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">value_storage_select_copy_constructor</a>&lt; T &gt; &gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__assignment.html">value_storage_delete_copy_assignment</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">value_storage_select_copy_constructor</a>&lt; T &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:a60b45a04e0528eb7984016cd6a5718f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c6fb6301887d33f08cb399962e3702"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a41c6fb6301887d33f08cb399962e3702"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a41c6fb6301887d33f08cb399962e3702">value_storage_select_copy_assignment</a> = std::conditional_t&lt; std::is_trivially_copy_assignable&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; T &gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">value_storage_select_move_assignment</a>&lt; T &gt;, std::conditional_t&lt; std::is_copy_assignable&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; T &gt; &gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial__copy__assignment.html">value_storage_nontrivial_copy_assignment</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">value_storage_select_move_assignment</a>&lt; T &gt; &gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__assignment.html">value_storage_delete_copy_assignment</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">value_storage_select_move_assignment</a>&lt; T &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:a41c6fb6301887d33f08cb399962e3702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9f9b7ee76ce130036094b105665f84"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c9f9b7ee76ce130036094b105665f84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9c9f9b7ee76ce130036094b105665f84">value_storage_select_impl</a> = <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a41c6fb6301887d33f08cb399962e3702">value_storage_select_copy_assignment</a>&lt; T &gt;</td></tr>
<tr class="separator:a9c9f9b7ee76ce130036094b105665f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25feac6a9f3a4e942c914c5406db588"><td class="memTemplParams" colspan="2">template&lt;class Base , class R , class S , class P , class NoValuePolicy &gt; </td></tr>
<tr class="memitem:ad25feac6a9f3a4e942c914c5406db588"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ad25feac6a9f3a4e942c914c5406db588">select_outcome_observers_payload_or_exception</a> = std::conditional_t&lt; <a class="el" href="structoutcome__v2__xxx_1_1trait_1_1is__exception__ptr.html">trait::is_exception_ptr</a>&lt; P &gt;::value, <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__exception__observers.html">detail::outcome_exception_observers</a>&lt; Base, R, S, P, NoValuePolicy &gt;, <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__payload__observers.html">detail::outcome_payload_observers</a>&lt; Base, R, S, P, NoValuePolicy &gt; &gt;</td></tr>
<tr class="separator:ad25feac6a9f3a4e942c914c5406db588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081424b6f6831386bb67a1f313ec101f"><td class="memTemplParams" colspan="2">template&lt;class R , class S , class P , class NoValuePolicy &gt; </td></tr>
<tr class="memitem:a081424b6f6831386bb67a1f313ec101f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a081424b6f6831386bb67a1f313ec101f">select_outcome_impl2</a> = <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ad25feac6a9f3a4e942c914c5406db588">select_outcome_observers_payload_or_exception</a>&lt; <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">detail::result_final</a>&lt; R, S, NoValuePolicy &gt;, R, S, P, NoValuePolicy &gt;</td></tr>
<tr class="separator:a081424b6f6831386bb67a1f313ec101f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc01d2b6bb07604dd472465a304049e0"><td class="memTemplParams" colspan="2">template&lt;class R , class S , class P , class NoValuePolicy &gt; </td></tr>
<tr class="memitem:afc01d2b6bb07604dd472465a304049e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#afc01d2b6bb07604dd472465a304049e0">select_outcome_impl</a> = std::conditional_t&lt; std::is_base_of&lt; std::error_code, S &gt;::value &amp;&amp;<a class="el" href="structoutcome__v2__xxx_1_1trait_1_1is__exception__ptr.html">trait::is_exception_ptr</a>&lt; P &gt;::value, <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__failure__observers.html">detail::outcome_failure_observers</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a081424b6f6831386bb67a1f313ec101f">select_outcome_impl2</a>&lt; R, S, P, NoValuePolicy &gt;, R, S, P, NoValuePolicy &gt;, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a081424b6f6831386bb67a1f313ec101f">select_outcome_impl2</a>&lt; R, S, P, NoValuePolicy &gt; &gt;</td></tr>
<tr class="separator:afc01d2b6bb07604dd472465a304049e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa9d2e00289b6c08f18620420d3ffce25"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , class W &gt; </td></tr>
<tr class="memitem:aa9d2e00289b6c08f18620420d3ffce25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#aa9d2e00289b6c08f18620420d3ffce25">operator==</a> (const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; W &gt; &amp;a, const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;b) noexcept(noexcept(b==a))</td></tr>
<tr class="memdesc:aa9d2e00289b6c08f18620420d3ffce25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls b == a.  <a href="#aa9d2e00289b6c08f18620420d3ffce25">More...</a><br /></td></tr>
<tr class="separator:aa9d2e00289b6c08f18620420d3ffce25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2605a0eff58e7d0506f86198186c3cf4"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , class W &gt; </td></tr>
<tr class="memitem:a2605a0eff58e7d0506f86198186c3cf4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a2605a0eff58e7d0506f86198186c3cf4">operator==</a> (const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; W, void &gt; &amp;a, const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;b) noexcept(noexcept(b==a))</td></tr>
<tr class="memdesc:a2605a0eff58e7d0506f86198186c3cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls b == a.  <a href="#a2605a0eff58e7d0506f86198186c3cf4">More...</a><br /></td></tr>
<tr class="separator:a2605a0eff58e7d0506f86198186c3cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33d543687e0dc7ac69922b0d5b1ba99"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , class W &gt; </td></tr>
<tr class="memitem:ad33d543687e0dc7ac69922b0d5b1ba99"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ad33d543687e0dc7ac69922b0d5b1ba99">operator!=</a> (const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; W &gt; &amp;a, const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;b) noexcept(noexcept(b==a))</td></tr>
<tr class="memdesc:ad33d543687e0dc7ac69922b0d5b1ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls b != a.  <a href="#ad33d543687e0dc7ac69922b0d5b1ba99">More...</a><br /></td></tr>
<tr class="separator:ad33d543687e0dc7ac69922b0d5b1ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8769c1287593756fbb62252d3b8d89"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , class W &gt; </td></tr>
<tr class="memitem:a5c8769c1287593756fbb62252d3b8d89"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a5c8769c1287593756fbb62252d3b8d89">operator!=</a> (const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; W, void &gt; &amp;a, const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;b) noexcept(noexcept(b==a))</td></tr>
<tr class="memdesc:a5c8769c1287593756fbb62252d3b8d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls b != a.  <a href="#a5c8769c1287593756fbb62252d3b8d89">More...</a><br /></td></tr>
<tr class="separator:a5c8769c1287593756fbb62252d3b8d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777c9ce6202841faac3e28d1a163a457"><td class="memTemplParams" colspan="2">template&lt;class T , class U , typename  = decltype( std::declval&lt;T&gt;() == std::declval&lt;U&gt;() )&gt; </td></tr>
<tr class="memitem:a777c9ce6202841faac3e28d1a163a457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a777c9ce6202841faac3e28d1a163a457">safe_compare_equal</a> (const T &amp;a, const U &amp;b) noexcept(noexcept(std::declval&lt; T &gt;()==std::declval&lt; U &gt;()))</td></tr>
<tr class="separator:a777c9ce6202841faac3e28d1a163a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdddb512d6b89765d21fdbfa9e1319a"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3bdddb512d6b89765d21fdbfa9e1319a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a3bdddb512d6b89765d21fdbfa9e1319a">safe_compare_equal</a> (T &amp;&amp;, U &amp;&amp;) noexcept</td></tr>
<tr class="separator:a3bdddb512d6b89765d21fdbfa9e1319a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8881fa9ee29ecd6f16c0216cb561350c"><td class="memTemplParams" colspan="2">template&lt;class T , class U , typename  = decltype( std::declval&lt;T&gt;() != std::declval&lt;U&gt;() )&gt; </td></tr>
<tr class="memitem:a8881fa9ee29ecd6f16c0216cb561350c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a8881fa9ee29ecd6f16c0216cb561350c">safe_compare_notequal</a> (const T &amp;a, const U &amp;b) noexcept(noexcept(std::declval&lt; T &gt;() !=std::declval&lt; U &gt;()))</td></tr>
<tr class="separator:a8881fa9ee29ecd6f16c0216cb561350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616a49edb247a38f7e474c0c42594e47"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a616a49edb247a38f7e474c0c42594e47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a616a49edb247a38f7e474c0c42594e47">safe_compare_notequal</a> (T &amp;&amp;, U &amp;&amp;) noexcept</td></tr>
<tr class="separator:a616a49edb247a38f7e474c0c42594e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c56c018efba66fe153c18a0087bc2c0"><td class="memTemplParams" colspan="2">template&lt;class State , class E &gt; </td></tr>
<tr class="memitem:a4c56c018efba66fe153c18a0087bc2c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a4c56c018efba66fe153c18a0087bc2c0">_set_error_is_errno</a> (State &amp;, const E &amp;)</td></tr>
<tr class="separator:a4c56c018efba66fe153c18a0087bc2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33eefef2f210e575e8bba34186a5f52"><td class="memTemplParams" colspan="2">template&lt;class State &gt; </td></tr>
<tr class="memitem:ad33eefef2f210e575e8bba34186a5f52"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ad33eefef2f210e575e8bba34186a5f52">_set_error_is_errno</a> (State &amp;state, const std::error_code &amp;error)</td></tr>
<tr class="separator:ad33eefef2f210e575e8bba34186a5f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffd746a65c8febeafef3b46c9e7282d"><td class="memTemplParams" colspan="2">template&lt;class State &gt; </td></tr>
<tr class="memitem:aeffd746a65c8febeafef3b46c9e7282d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#aeffd746a65c8febeafef3b46c9e7282d">_set_error_is_errno</a> (State &amp;state, const std::error_condition &amp;error)</td></tr>
<tr class="separator:aeffd746a65c8febeafef3b46c9e7282d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef925c9517559dbdc12d3c92bb8df6f"><td class="memTemplParams" colspan="2">template&lt;class State &gt; </td></tr>
<tr class="memitem:a7ef925c9517559dbdc12d3c92bb8df6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a7ef925c9517559dbdc12d3c92bb8df6f">_set_error_is_errno</a> (State &amp;state, const std::errc &amp;)</td></tr>
<tr class="separator:a7ef925c9517559dbdc12d3c92bb8df6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2877258902edd1f32c165d7fe3eb724c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2877258902edd1f32c165d7fe3eb724c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a2877258902edd1f32c165d7fe3eb724c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a2877258902edd1f32c165d7fe3eb724c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f638ca4f99395b18babfcd96bd5b2d8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a0f638ca4f99395b18babfcd96bd5b2d8">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; void &gt; &amp;v)</td></tr>
<tr class="separator:a0f638ca4f99395b18babfcd96bd5b2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0595117bebec90c87d3ae39da0468902"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0595117bebec90c87d3ae39da0468902"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a0595117bebec90c87d3ae39da0468902">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial.html">value_storage_nontrivial</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a0595117bebec90c87d3ae39da0468902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fab0d8a1d3a4730a8ae7689d22d463e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4fab0d8a1d3a4730a8ae7689d22d463e"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a4fab0d8a1d3a4730a8ae7689d22d463e">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a4fab0d8a1d3a4730a8ae7689d22d463e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a5f01520baad284c7514649a1e1f9d"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#af3a5f01520baad284c7514649a1e1f9d">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; void &gt;&gt; &amp;v)</td></tr>
<tr class="separator:af3a5f01520baad284c7514649a1e1f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea9157ff083a9b4a7478b6a160c16ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ea9157ff083a9b4a7478b6a160c16ed"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a0ea9157ff083a9b4a7478b6a160c16ed">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial.html">value_storage_nontrivial</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a0ea9157ff083a9b4a7478b6a160c16ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c2c01d34a229d1dd135a66e03c06f4"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = std::enable_if_t&lt; !std::is_constructible&lt;std::error_code, T&gt;::value &gt;&gt; </td></tr>
<tr class="memitem:a38c2c01d34a229d1dd135a66e03c06f4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a38c2c01d34a229d1dd135a66e03c06f4">safe_message</a> (T &amp;&amp;)</td></tr>
<tr class="separator:a38c2c01d34a229d1dd135a66e03c06f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272a1c16961b6d9eab6943ed96148b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ac272a1c16961b6d9eab6943ed96148b4">safe_message</a> (const std::error_code &amp;ec)</td></tr>
<tr class="separator:ac272a1c16961b6d9eab6943ed96148b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6889010117cc82c367df664129f331f"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;!trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af6889010117cc82c367df664129f331f"><td class="memTemplItemLeft" align="right" valign="top">constexpr const V &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#af6889010117cc82c367df664129f331f">extract_exception_payload_from_failure</a> (const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;v, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>=<a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>())</td></tr>
<tr class="separator:af6889010117cc82c367df664129f331f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7e2d2989bfcf7604dddaf3ad84504"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;!trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a63a7e2d2989bfcf7604dddaf3ad84504"><td class="memTemplItemLeft" align="right" valign="top">constexpr V &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a63a7e2d2989bfcf7604dddaf3ad84504">extract_exception_payload_from_failure</a> (<a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&amp;v, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>=<a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>())</td></tr>
<tr class="separator:a63a7e2d2989bfcf7604dddaf3ad84504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6725e7c0e0bf791dddbc125e197017b7"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a6725e7c0e0bf791dddbc125e197017b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr const V &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a6725e7c0e0bf791dddbc125e197017b7">extract_exception_payload_from_failure</a> (const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;v, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>=<a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>())</td></tr>
<tr class="separator:a6725e7c0e0bf791dddbc125e197017b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc3607e558b08081c039060a69bae2f"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:addc3607e558b08081c039060a69bae2f"><td class="memTemplItemLeft" align="right" valign="top">constexpr V &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#addc3607e558b08081c039060a69bae2f">extract_exception_payload_from_failure</a> (<a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&amp;v, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>=<a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>())</td></tr>
<tr class="separator:addc3607e558b08081c039060a69bae2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf14d5ef43c18efc3b145cc97fcfe5"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3caf14d5ef43c18efc3b145cc97fcfe5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a3caf14d5ef43c18efc3b145cc97fcfe5">extract_exception_payload_from_failure</a> (const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, void &gt; &amp;)</td></tr>
<tr class="separator:a3caf14d5ef43c18efc3b145cc97fcfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7316cbfe6aa9879c5b5f621e9836f56"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab7316cbfe6aa9879c5b5f621e9836f56"><td class="memTemplItemLeft" align="right" valign="top">constexpr const U &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ab7316cbfe6aa9879c5b5f621e9836f56">extract_value_from_success</a> (const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; U &gt; &amp;v)</td></tr>
<tr class="separator:ab7316cbfe6aa9879c5b5f621e9836f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94410b3a50d4b03238733b27ffc36c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1a94410b3a50d4b03238733b27ffc36c"><td class="memTemplItemLeft" align="right" valign="top">constexpr U &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a1a94410b3a50d4b03238733b27ffc36c">extract_value_from_success</a> (<a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; U &gt; &amp;&amp;v)</td></tr>
<tr class="separator:a1a94410b3a50d4b03238733b27ffc36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2734b7ab70e45e7f01f40bb555ac1ce7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2734b7ab70e45e7f01f40bb555ac1ce7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a2734b7ab70e45e7f01f40bb555ac1ce7">extract_value_from_success</a> (const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; void &gt; &amp;)</td></tr>
<tr class="separator:a2734b7ab70e45e7f01f40bb555ac1ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc75eca2f35dc6ace500a706b0d9e6ed"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V &gt; </td></tr>
<tr class="memitem:acc75eca2f35dc6ace500a706b0d9e6ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr const U &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#acc75eca2f35dc6ace500a706b0d9e6ed">extract_error_from_failure</a> (const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;v)</td></tr>
<tr class="separator:acc75eca2f35dc6ace500a706b0d9e6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd138e81a77464237680fba1ca2699f"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V &gt; </td></tr>
<tr class="memitem:abcd138e81a77464237680fba1ca2699f"><td class="memTemplItemLeft" align="right" valign="top">constexpr U &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#abcd138e81a77464237680fba1ca2699f">extract_error_from_failure</a> (<a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&amp;v)</td></tr>
<tr class="separator:abcd138e81a77464237680fba1ca2699f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3cd2c680a175d863ec26d76fcf233d"><td class="memTemplParams" colspan="2">template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:a2b3cd2c680a175d863ec26d76fcf233d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a2b3cd2c680a175d863ec26d76fcf233d">extract_error_from_failure</a> (const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; void, V &gt; &amp;)</td></tr>
<tr class="separator:a2b3cd2c680a175d863ec26d76fcf233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a757056d8571ee8c90f71c1dad7dc1972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757056d8571ee8c90f71c1dad7dc1972">&#9670;&nbsp;</a></span>devoid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">outcome_v2_xxx::detail::devoid</a> = typedef std::conditional_t&lt;std::is_void&lt;T&gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1void__type.html">void_type</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50aa938646ec2783f32e04eb97b65be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aa938646ec2783f32e04eb97b65be4">&#9670;&nbsp;</a></span>is_nothrow_swappable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a50aa938646ec2783f32e04eb97b65be4">outcome_v2_xxx::detail::is_nothrow_swappable</a> = typedef <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1__is__nothrow__swappable_1_1is__nothrow__swappable.html">_is_nothrow_swappable::is_nothrow_swappable</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc01d2b6bb07604dd472465a304049e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc01d2b6bb07604dd472465a304049e0">&#9670;&nbsp;</a></span>select_outcome_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class S , class P , class NoValuePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#afc01d2b6bb07604dd472465a304049e0">outcome_v2_xxx::detail::select_outcome_impl</a> = typedef std::conditional_t&lt;std::is_base_of&lt;std::error_code, S&gt;::value &amp;&amp; <a class="el" href="structoutcome__v2__xxx_1_1trait_1_1is__exception__ptr.html">trait::is_exception_ptr</a>&lt;P&gt;::value, <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__failure__observers.html">detail::outcome_failure_observers</a>&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a081424b6f6831386bb67a1f313ec101f">select_outcome_impl2</a>&lt;R, S, P, NoValuePolicy&gt;, R, S, P, NoValuePolicy&gt;, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a081424b6f6831386bb67a1f313ec101f">select_outcome_impl2</a>&lt;R, S, P, NoValuePolicy&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a081424b6f6831386bb67a1f313ec101f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081424b6f6831386bb67a1f313ec101f">&#9670;&nbsp;</a></span>select_outcome_impl2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class S , class P , class NoValuePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a081424b6f6831386bb67a1f313ec101f">outcome_v2_xxx::detail::select_outcome_impl2</a> = typedef <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ad25feac6a9f3a4e942c914c5406db588">select_outcome_observers_payload_or_exception</a>&lt;<a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">detail::result_final</a>&lt;R, S, NoValuePolicy&gt;, R, S, P, NoValuePolicy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad25feac6a9f3a4e942c914c5406db588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25feac6a9f3a4e942c914c5406db588">&#9670;&nbsp;</a></span>select_outcome_observers_payload_or_exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base , class R , class S , class P , class NoValuePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ad25feac6a9f3a4e942c914c5406db588">outcome_v2_xxx::detail::select_outcome_observers_payload_or_exception</a> = typedef std::conditional_t&lt;<a class="el" href="structoutcome__v2__xxx_1_1trait_1_1is__exception__ptr.html">trait::is_exception_ptr</a>&lt;P&gt;::value, <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__exception__observers.html">detail::outcome_exception_observers</a>&lt;Base, R, S, P, NoValuePolicy&gt;, <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1outcome__payload__observers.html">detail::outcome_payload_observers</a>&lt;Base, R, S, P, NoValuePolicy&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80d582ee6958238c92b5d246a7e8c87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d582ee6958238c92b5d246a7e8c87e">&#9670;&nbsp;</a></span>select_result_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class EC , class NoValuePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a80d582ee6958238c92b5d246a7e8c87e">outcome_v2_xxx::detail::select_result_impl</a> = typedef <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__error__observers.html">result_error_observers</a>&lt;<a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__value__observers.html">result_value_observers</a>&lt;<a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__storage.html">result_storage</a>&lt;R, EC, NoValuePolicy&gt;, R, NoValuePolicy&gt;, EC, NoValuePolicy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac29d920102ef903d21a70739819dd60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29d920102ef903d21a70739819dd60d">&#9670;&nbsp;</a></span>status_bitfield_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#ac29d920102ef903d21a70739819dd60d">outcome_v2_xxx::detail::status_bitfield_type</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41c6fb6301887d33f08cb399962e3702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c6fb6301887d33f08cb399962e3702">&#9670;&nbsp;</a></span>value_storage_select_copy_assignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a41c6fb6301887d33f08cb399962e3702">outcome_v2_xxx::detail::value_storage_select_copy_assignment</a> = typedef std::conditional_t&lt;std::is_trivially_copy_assignable&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt;T&gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">value_storage_select_move_assignment</a>&lt;T&gt;, std::conditional_t&lt;std::is_copy_assignable&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt;T&gt; &gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial__copy__assignment.html">value_storage_nontrivial_copy_assignment</a>&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">value_storage_select_move_assignment</a>&lt;T&gt; &gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__assignment.html">value_storage_delete_copy_assignment</a>&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">value_storage_select_move_assignment</a>&lt;T&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a8f3438b12021061d0d2e88bc218ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8f3438b12021061d0d2e88bc218ae1">&#9670;&nbsp;</a></span>value_storage_select_copy_constructor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">outcome_v2_xxx::detail::value_storage_select_copy_constructor</a> = typedef std::conditional_t&lt;std::is_copy_constructible&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt;T&gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a51e4563e0b111a0ff99ba632291bc69b">value_storage_select_move_constructor</a>&lt;T&gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__constructor.html">value_storage_delete_copy_constructor</a>&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a51e4563e0b111a0ff99ba632291bc69b">value_storage_select_move_constructor</a>&lt;T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c9f9b7ee76ce130036094b105665f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9f9b7ee76ce130036094b105665f84">&#9670;&nbsp;</a></span>value_storage_select_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9c9f9b7ee76ce130036094b105665f84">outcome_v2_xxx::detail::value_storage_select_impl</a> = typedef <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a41c6fb6301887d33f08cb399962e3702">value_storage_select_copy_assignment</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60b45a04e0528eb7984016cd6a5718f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b45a04e0528eb7984016cd6a5718f9">&#9670;&nbsp;</a></span>value_storage_select_move_assignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a60b45a04e0528eb7984016cd6a5718f9">outcome_v2_xxx::detail::value_storage_select_move_assignment</a> = typedef std::conditional_t&lt;std::is_trivially_move_assignable&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt;T&gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">value_storage_select_copy_constructor</a>&lt;T&gt;, std::conditional_t&lt;std::is_move_assignable&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt;T&gt; &gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial__move__assignment.html">value_storage_nontrivial_move_assignment</a>&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">value_storage_select_copy_constructor</a>&lt;T&gt; &gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__copy__assignment.html">value_storage_delete_copy_assignment</a>&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a9a8f3438b12021061d0d2e88bc218ae1">value_storage_select_copy_constructor</a>&lt;T&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e4563e0b111a0ff99ba632291bc69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e4563e0b111a0ff99ba632291bc69b">&#9670;&nbsp;</a></span>value_storage_select_move_constructor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a51e4563e0b111a0ff99ba632291bc69b">outcome_v2_xxx::detail::value_storage_select_move_constructor</a> = typedef std::conditional_t&lt;std::is_move_constructible&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt;T&gt; &gt;::value, <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#abe8f02f9f1a51c29619fc7c7edbb9c8d">value_storage_select_trivality</a>&lt;T&gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__delete__move__constructor.html">value_storage_delete_move_constructor</a>&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#abe8f02f9f1a51c29619fc7c7edbb9c8d">value_storage_select_trivality</a>&lt;T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe8f02f9f1a51c29619fc7c7edbb9c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8f02f9f1a51c29619fc7c7edbb9c8d">&#9670;&nbsp;</a></span>value_storage_select_trivality</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#abe8f02f9f1a51c29619fc7c7edbb9c8d">outcome_v2_xxx::detail::value_storage_select_trivality</a> = typedef std::conditional_t&lt;std::is_trivially_copyable&lt;<a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt;T&gt; &gt;::value, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt;T&gt;, <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial.html">value_storage_nontrivial</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4c56c018efba66fe153c18a0087bc2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c56c018efba66fe153c18a0087bc2c0">&#9670;&nbsp;</a></span>_set_error_is_errno() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void outcome_v2_xxx::detail::_set_error_is_errno </td>
          <td>(</td>
          <td class="paramtype">State &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a id="ad33eefef2f210e575e8bba34186a5f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33eefef2f210e575e8bba34186a5f52">&#9670;&nbsp;</a></span>_set_error_is_errno() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void outcome_v2_xxx::detail::_set_error_is_errno </td>
          <td>(</td>
          <td class="paramtype">State &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">if</span>(error.category() == std::generic_category()</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="preprocessor">#ifndef _WIN32</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;       || error.category() == std::system_category()</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;       )</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      state._status |= status_error_is_errno;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    }</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="aeffd746a65c8febeafef3b46c9e7282d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffd746a65c8febeafef3b46c9e7282d">&#9670;&nbsp;</a></span>_set_error_is_errno() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void outcome_v2_xxx::detail::_set_error_is_errno </td>
          <td>(</td>
          <td class="paramtype">State &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::error_condition &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordflow">if</span>(error.category() == std::generic_category()</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="preprocessor">#ifndef _WIN32</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;       || error.category() == std::system_category()</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;       )</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    {</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      state._status |= status_error_is_errno;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    }</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a7ef925c9517559dbdc12d3c92bb8df6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef925c9517559dbdc12d3c92bb8df6f">&#9670;&nbsp;</a></span>_set_error_is_errno() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void outcome_v2_xxx::detail::_set_error_is_errno </td>
          <td>(</td>
          <td class="paramtype">State &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::errc &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;{ state._status |= status_error_is_errno; }</div></div><!-- fragment -->
</div>
</div>
<a id="acc75eca2f35dc6ace500a706b0d9e6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc75eca2f35dc6ace500a706b0d9e6ed">&#9670;&nbsp;</a></span>extract_error_from_failure() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const U&amp; outcome_v2_xxx::detail::extract_error_from_failure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;{ <span class="keywordflow">return</span> v.error; }</div></div><!-- fragment -->
</div>
</div>
<a id="abcd138e81a77464237680fba1ca2699f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd138e81a77464237680fba1ca2699f">&#9670;&nbsp;</a></span>extract_error_from_failure() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U&amp;&amp; outcome_v2_xxx::detail::extract_error_from_failure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{ <span class="keywordflow">return</span> std::move(v.error); }</div></div><!-- fragment -->
</div>
</div>
<a id="a2b3cd2c680a175d863ec26d76fcf233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3cd2c680a175d863ec26d76fcf233d">&#9670;&nbsp;</a></span>extract_error_from_failure() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T outcome_v2_xxx::detail::extract_error_from_failure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; void, V &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;{ <span class="keywordflow">return</span> T{}; }</div></div><!-- fragment -->
</div>
</div>
<a id="af6889010117cc82c367df664129f331f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6889010117cc82c367df664129f331f">&#9670;&nbsp;</a></span>extract_exception_payload_from_failure() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;!trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const V&amp; outcome_v2_xxx::detail::extract_exception_payload_from_failure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;{ <span class="keywordflow">return</span> v.payload; }</div></div><!-- fragment -->
</div>
</div>
<a id="a63a7e2d2989bfcf7604dddaf3ad84504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a7e2d2989bfcf7604dddaf3ad84504">&#9670;&nbsp;</a></span>extract_exception_payload_from_failure() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;!trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr V&amp;&amp; outcome_v2_xxx::detail::extract_exception_payload_from_failure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__payload__from__failure.html">enable_payload_from_failure</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{ <span class="keywordflow">return</span> std::move(v.payload); }</div></div><!-- fragment -->
</div>
</div>
<a id="a6725e7c0e0bf791dddbc125e197017b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6725e7c0e0bf791dddbc125e197017b7">&#9670;&nbsp;</a></span>extract_exception_payload_from_failure() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const V&amp; outcome_v2_xxx::detail::extract_exception_payload_from_failure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;{ <span class="keywordflow">return</span> v.exception; }</div></div><!-- fragment -->
</div>
</div>
<a id="addc3607e558b08081c039060a69bae2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc3607e558b08081c039060a69bae2f">&#9670;&nbsp;</a></span>extract_exception_payload_from_failure() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , typename  = std::enable_if_t&lt;trait::is_exception_ptr&lt;V&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr V&amp;&amp; outcome_v2_xxx::detail::extract_exception_payload_from_failure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, V &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1enable__exception__from__failure.html">enable_exception_from_failure</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;{ <span class="keywordflow">return</span> std::move(v.exception); }</div></div><!-- fragment -->
</div>
</div>
<a id="a3caf14d5ef43c18efc3b145cc97fcfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caf14d5ef43c18efc3b145cc97fcfe5">&#9670;&nbsp;</a></span>extract_exception_payload_from_failure() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T outcome_v2_xxx::detail::extract_exception_payload_from_failure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; U, void &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;{ <span class="keywordflow">return</span> T{}; }</div></div><!-- fragment -->
</div>
</div>
<a id="ab7316cbfe6aa9879c5b5f621e9836f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7316cbfe6aa9879c5b5f621e9836f56">&#9670;&nbsp;</a></span>extract_value_from_success() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const U&amp; outcome_v2_xxx::detail::extract_value_from_success </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;{ <span class="keywordflow">return</span> v.value; }</div></div><!-- fragment -->
</div>
</div>
<a id="a1a94410b3a50d4b03238733b27ffc36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a94410b3a50d4b03238733b27ffc36c">&#9670;&nbsp;</a></span>extract_value_from_success() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U&amp;&amp; outcome_v2_xxx::detail::extract_value_from_success </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;{ <span class="keywordflow">return</span> std::move(v.value); }</div></div><!-- fragment -->
</div>
</div>
<a id="a2734b7ab70e45e7f01f40bb555ac1ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2734b7ab70e45e7f01f40bb555ac1ce7">&#9670;&nbsp;</a></span>extract_value_from_success() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T outcome_v2_xxx::detail::extract_value_from_success </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;{ <span class="keywordflow">return</span> T{}; }</div></div><!-- fragment -->
</div>
</div>
<a id="ad33d543687e0dc7ac69922b0d5b1ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33d543687e0dc7ac69922b0d5b1ba99">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool outcome_v2_xxx::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls b != a. </p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;{ <span class="keywordflow">return</span> b != a; }</div></div><!-- fragment -->
</div>
</div>
<a id="a5c8769c1287593756fbb62252d3b8d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8769c1287593756fbb62252d3b8d89">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool outcome_v2_xxx::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; W, void &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls b != a. </p>
<div class="fragment"><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;{ <span class="keywordflow">return</span> b != a; }</div></div><!-- fragment -->
</div>
</div>
<a id="a2877258902edd1f32c165d7fe3eb724c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2877258902edd1f32c165d7fe3eb724c">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; outcome_v2_xxx::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  {</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    s &lt;&lt; v._status &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">if</span>((v._status &amp; status_have_value) != 0)</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    {</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      s &lt;&lt; v._value;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">return</span> s;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a0f638ca4f99395b18babfcd96bd5b2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f638ca4f99395b18babfcd96bd5b2d8">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; outcome_v2_xxx::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  {</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    s &lt;&lt; v._status &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">return</span> s;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a0595117bebec90c87d3ae39da0468902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0595117bebec90c87d3ae39da0468902">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; outcome_v2_xxx::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial.html">value_storage_nontrivial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    s &lt;&lt; v._status &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">if</span>((v._status &amp; status_have_value) != 0)</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      s &lt;&lt; v._value;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    }</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">return</span> s;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="aa9d2e00289b6c08f18620420d3ffce25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d2e00289b6c08f18620420d3ffce25">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool outcome_v2_xxx::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1success__type.html">success_type</a>&lt; W &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls b == a. </p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{ <span class="keywordflow">return</span> b == a; }</div></div><!-- fragment -->
</div>
</div>
<a id="a2605a0eff58e7d0506f86198186c3cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2605a0eff58e7d0506f86198186c3cf4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V , class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool outcome_v2_xxx::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoutcome__v2__xxx_1_1failure__type.html">failure_type</a>&lt; W, void &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoutcome__v2__xxx_1_1detail_1_1result__final.html">result_final</a>&lt; T, U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls b == a. </p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;{ <span class="keywordflow">return</span> b == a; }</div></div><!-- fragment -->
</div>
</div>
<a id="a4fab0d8a1d3a4730a8ae7689d22d463e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fab0d8a1d3a4730a8ae7689d22d463e">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; outcome_v2_xxx::detail::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    v = value_storage_trivial&lt;T&gt;();</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    s &gt;&gt; v._status;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">if</span>((v._status &amp; status_have_value) != 0)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="keyword">new</span>(&amp;v._value) decltype(v._value)();</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      s &gt;&gt; v._value;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">return</span> s;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="af3a5f01520baad284c7514649a1e1f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a5f01520baad284c7514649a1e1f9d">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; outcome_v2_xxx::detail::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__trivial.html">value_storage_trivial</a>&lt; <a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html#a757056d8571ee8c90f71c1dad7dc1972">devoid</a>&lt; void &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    v = value_storage_trivial&lt;devoid&lt;void&gt;&gt;();</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    s &gt;&gt; v._status;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">return</span> s;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a0ea9157ff083a9b4a7478b6a160c16ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea9157ff083a9b4a7478b6a160c16ed">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; outcome_v2_xxx::detail::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoutcome__v2__xxx_1_1detail_1_1value__storage__nontrivial.html">value_storage_nontrivial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    v = value_storage_nontrivial&lt;T&gt;();</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    s &gt;&gt; v._status;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">if</span>((v._status &amp; status_have_value) != 0)</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    {</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      <span class="keyword">new</span>(&amp;v._value) decltype(v._value)();</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      s &gt;&gt; v._value;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">return</span> s;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a777c9ce6202841faac3e28d1a163a457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777c9ce6202841faac3e28d1a163a457">&#9670;&nbsp;</a></span>safe_compare_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , typename  = decltype( std::declval&lt;T&gt;() == std::declval&lt;U&gt;() )&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool outcome_v2_xxx::detail::safe_compare_equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="comment">// std::cout &lt;&lt; &quot;Taken &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; == &quot; &lt;&lt; typeid(U).name() &lt;&lt; &quot; = &quot; &lt;&lt; (a == b) &lt;&lt; std::endl;</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">return</span> a == b;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a3bdddb512d6b89765d21fdbfa9e1319a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdddb512d6b89765d21fdbfa9e1319a">&#9670;&nbsp;</a></span>safe_compare_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool outcome_v2_xxx::detail::safe_compare_equal </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  {</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="comment">// std::cout &lt;&lt; &quot;Fallback &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; == &quot; &lt;&lt; typeid(U).name() &lt;&lt; &quot; = false&quot; &lt;&lt; std::endl;</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a8881fa9ee29ecd6f16c0216cb561350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8881fa9ee29ecd6f16c0216cb561350c">&#9670;&nbsp;</a></span>safe_compare_notequal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , typename  = decltype( std::declval&lt;T&gt;() != std::declval&lt;U&gt;() )&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool outcome_v2_xxx::detail::safe_compare_notequal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  {</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">// std::cout &lt;&lt; &quot;Taken &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; != &quot; &lt;&lt; typeid(U).name() &lt;&lt; &quot; = &quot; &lt;&lt; (a != b) &lt;&lt; std::endl;</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordflow">return</span> a != b;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a616a49edb247a38f7e474c0c42594e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616a49edb247a38f7e474c0c42594e47">&#9670;&nbsp;</a></span>safe_compare_notequal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool outcome_v2_xxx::detail::safe_compare_notequal </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  {</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="comment">// std::cout &lt;&lt; &quot;Fallback &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; != &quot; &lt;&lt; typeid(U).name() &lt;&lt; &quot; = true&quot; &lt;&lt; std::endl;</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a38c2c01d34a229d1dd135a66e03c06f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c2c01d34a229d1dd135a66e03c06f4">&#9670;&nbsp;</a></span>safe_message() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = std::enable_if_t&lt; !std::is_constructible&lt;std::error_code, T&gt;::value &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string outcome_v2_xxx::detail::safe_message </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;{ <span class="keywordflow">return</span> {}; }</div></div><!-- fragment -->
</div>
</div>
<a id="ac272a1c16961b6d9eab6943ed96148b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac272a1c16961b6d9eab6943ed96148b4">&#9670;&nbsp;</a></span>safe_message() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string outcome_v2_xxx::detail::safe_message </td>
          <td>(</td>
          <td class="paramtype">const std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;{ <span class="keywordflow">return</span> <span class="stringliteral">&quot; (&quot;</span> + ec.message() + <span class="stringliteral">&quot;)&quot;</span>; }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoutcome__v2__xxx.html">outcome_v2_xxx</a></li><li class="navelem"><a class="el" href="namespaceoutcome__v2__xxx_1_1detail.html">detail</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
