<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Outcome documentation</title>
    <link>https://ned14.github.io/outcome/</link>
    <description>Recent content in Home on Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ned14.github.io/outcome/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>User defined error types</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/udt-err/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/udt-err/</guid>
      <description>Let us imagine a some user defined value type (udt) and some user defined error type (err):
struct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; struct err { int a{0}; explicit err(int _a) : a(_a) { } err() = default; };  View this code on Github Firstly, note that both the udt and err types can be constructed from an int.</description>
    </item>
    
    <item>
      <title>-- What happens?</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/happens1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/happens1/</guid>
      <description>Let us run the code from the previous page:
ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_udts Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Apparently no exception was thrown? Correct. Nor was a value printed, though this will randomly vary depending on your compiler, libraries, the wind blowing on the day &amp;hellip;
You will probably find this surprising. This is because the default action for a user-defined error type is undefined behaviour.
Let&amp;rsquo;s demonstrate this by recompiling the code to use the undefined behaviour sanitiser and see what happens instead:</description>
    </item>
    
    <item>
      <title>Anatomy of a policy</title>
      <link>https://ned14.github.io/outcome/tutorial/policies/anatomy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/policies/anatomy/</guid>
      <description>A NoValuePolicy is quite simple. This is a complete policy, only the top half is needed if you never use the policy in an outcome.
struct blank_policy { //! Performs a narrow check of state, used in the assume_value() functions.  template &amp;lt;class Impl&amp;gt; static constexpr void narrow_value_check(Impl *self) noexcept; //! Performs a narrow check of state, used in the assume_error() functions.  template &amp;lt;class Impl&amp;gt; static constexpr void narrow_error_check(Impl *self) noexcept; //!</description>
    </item>
    
    <item>
      <title>Keeping state</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/keeping_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/keeping_state/</guid>
      <description>The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in an outcome&amp;lt;T, error_code, std::unique_ptr&amp;lt;stack_backtrace&amp;gt;&amp;gt; (see previous section on outcome&amp;lt;T, EC, P&amp;gt;). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.
We therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.</description>
    </item>
    
    <item>
      <title>Limitations</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/limitations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/limitations/</guid>
      <description>C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:
 A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept. A C++ function should annotated with extern &amp;quot;C&amp;quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI.</description>
    </item>
    
    <item>
      <title>The Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/payload/copy_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/payload/copy_file/</guid>
      <description>To see how payload-transporting outcome might be useful, consider the copy_file() API from the Filesystem TS:
namespace filesystem { /*! Copies the file at path `from` to path `to`. \returns True if file was successfully copied. \throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with `ec` being the error code reported by the operating system. */ bool copy_file(const path &amp;amp;from, const path &amp;amp;to); /*! Copies the file at path `from` to path `to`.</description>
    </item>
    
    <item>
      <title>ADL bridging</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/adl_bridging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/adl_bridging/</guid>
      <description>In the previous section outcome&amp;lt;T, EC, P&amp;gt;, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered throw_as_system_error_with_payload() function was to be found.
Here we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks.
namespace error_code_extended { // Use the error_code type as the ADL bridge for the hooks by creating a type here  // It can be any type that your localised result uses, including the value type but  // by localising the error code type here you prevent nasty surprises later when the  // value type you use doesn&amp;#39;t trigger the ADL bridge.</description>
    </item>
    
    <item>
      <title>Casting workaround</title>
      <link>https://ned14.github.io/outcome/tutorial/policies/cast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/policies/cast/</guid>
      <description>The templated Impl type on each policy function is decltype(*this) of the part of Outcome&amp;rsquo;s internal implementation which calls the policy. It may also be const, depending on the observer called. It is highly unlikely to be result&amp;lt;T, EC&amp;gt; or especially outcome&amp;lt;T, EC, EP|P&amp;gt;, so a very common thing you&amp;rsquo;ll need to do is static cast to a more derived form before use like this:
template &amp;lt;class R, class S, class P&amp;gt; struct outcome_policy { /*!</description>
    </item>
    
    <item>
      <title>Error code enums</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/enums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/enums/</guid>
      <description>Let&amp;rsquo;s replace err with something likely in many people&amp;rsquo;s code, a strongly typed enum:
struct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; enum class err { success, failure1, failure2 }; result&amp;lt;udt, err&amp;gt; res(err::failure1); // What happens here? What exception type is thrown?  try { std::cout &amp;lt;&amp;lt; *res.value() &amp;lt;&amp;lt; std::endl; } catch(const std::exception &amp;amp;e) { std::cerr &amp;lt;&amp;lt; &amp;#34;Exception thrown was &amp;#34; &amp;lt;&amp;lt; e.</description>
    </item>
    
    <item>
      <title>Example C&#43;&#43; function</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/example/</guid>
      <description>Let us start with a simple C++ function which we wish to make available to C code:
// Fill the supplied buffer with the integer v converted to a string, returning // length of string minus null terminator extern &amp;#34;C&amp;#34; outcome::result&amp;lt;size_t&amp;gt; to_string(char *buffer, size_t bufferlen, int v) noexcept { try { // Could throw an exception!  std::string temp(std::to_string(v)); // Will this string exceed the supplied buffer?  if(temp.size() + 1 &amp;gt; bufferlen) return std::errc::no_buffer_space; // Copy the string into the supplied buffer, and return length of string  memcpy(buffer, temp.</description>
    </item>
    
    <item>
      <title>Inspecting result&lt;T, EC&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/result/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/result/inspecting/</guid>
      <description>Suppose we will be writing function print_half that takes an integral number (however big) represented as an std::string and outputs a number which is twice smaller:
outcome::result&amp;lt;void&amp;gt; print_half(const std::string&amp;amp; text);  View this code on Github Type result&amp;lt;void&amp;gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. Class template result&amp;lt;&amp;gt; is declared with attribute [[nodiscard]], which means compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).</description>
    </item>
    
    <item>
      <title>Upgrading the Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/payload/copy_file2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/payload/copy_file2/</guid>
      <description>An Outcome based solution looks deceptively simple initially, but there is more to it than it appears.
namespace filesystem2 { // Paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { path path1, path2; }; // Localise an outcome implementation specific to this namespace. Normally would just  // be `result`, but for clarity we&amp;#39;ll use `fs_result`.  template &amp;lt;class T&amp;gt; using fs_result = outcome::outcome&amp;lt;T, std::error_code, failure_info&amp;gt;; /*!</description>
    </item>
    
    <item>
      <title>-- What happens?</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/happens2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/happens2/</guid>
      <description>Let us run the code from the previous page:
ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums1 Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Also undefined behaviour. This is because Outcome doesn&amp;rsquo;t know what to do with a strongly typed enum any more than some user defined struct.
Let&amp;rsquo;s register our error code enum with the C++ standard library. This causes Outcome to treat it quite differently.
struct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; enum class err { success, failure1, failure2 }; // Tell the standard library that enum err is an error code enum // by specialising the is_error_code_enum trait.</description>
    </item>
    
    <item>
      <title>Result &#43; Outcome</title>
      <link>https://ned14.github.io/outcome/tutorial/policies/universal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/policies/universal/</guid>
      <description>These are the precanned policies suitable for use with both result and outcome:
 all_narrow Wide checks call their narrow check cousins only. Narrow checks call __builtin_unreachable() on compilers which support that intrinsic. exception_ptr_rethrow&amp;lt;T, EC, EP&amp;gt; Policy interpreting either EC or EP as meeting the std::exception_ptr contract. If there is no value, .value() will std::rethrow_exception(error) if EP is void, else std::rethrow_exception(exception). .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;quot;no error&amp;quot;)) if there is no error. The narrow checks call __builtin_unreachable() on compilers which support that intrinsic.</description>
    </item>
    
    <item>
      <title>-- Now what happens?</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/happens3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/happens3/</guid>
      <description>Let us run the code from the previous page:
ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums2 Exception thrown was failure1 ned@lyta:~/outcome/build_posix$  Ah so now we are throwing a C++ exception on incorrect observation! This is because we registered our error code enum with the C++ standard library and in so doing, we also told the standard library how our error code interacts with std::error_code and thus std::system_error.
Outcome&amp;rsquo;s default action when incorrectly observing a result or outcome with a EC type where std::is_error_code_enum&amp;lt;EC&amp;gt; is true, or std::is_error_condition_enum&amp;lt;EC&amp;gt; is true, is to throw a std::system_error(make_error_code(.</description>
    </item>
    
    <item>
      <title>Calling it from C</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/example2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/example2/</guid>
      <description>Now let us call our result returning C++ function from C:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; // for strerror// This header in Outcome is pure C, it provides a suite of C helper macros #include &amp;#34;../../../include/outcome/result.h&amp;#34; // Declare our C++ function&amp;#39;s returning result type. Only needs to be done once. CXX_DECLARE_RESULT_EC(size_t, size_t); // Tell C about our C++ function extern CXX_RESULT_EC(size_t) to_string(char *buffer, size_t bufferlen, int v); void print(int v) { char buffer[4]; CXX_RESULT_EC(size_t) res; res = to_string(buffer, sizeof(buffer), v); if(CXX_RESULT_HAS_VALUE(res)) { printf(&amp;#34;to_string(%d) fills buffer with &amp;#39;%s&amp;#39; of %zu characters\n&amp;#34;, v, buffer, res.</description>
    </item>
    
    <item>
      <title>Hook result</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/hook_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/hook_result/</guid>
      <description>We now tell Outcome that for every instance of our localised result&amp;lt;T&amp;gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.
namespace error_code_extended { // Specialise the result construction hook for our localised result  // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace  // if the result is errored.</description>
    </item>
    
    <item>
      <title>Inspecting outcome&lt;T, EC, EP&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/outcome/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/outcome/inspecting/</guid>
      <description>Continuing with the previous example, in Layer3 we obtain an outcome&amp;lt;double&amp;gt; which may store a double or an std::error_code or an std::exception_ptr. Layer3 uses exceptions to indicate failure, so we want to turn a failed result into an exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_codes:
namespace Layer3 { auto run() -&amp;gt; double // may throw  { if (outcome::outcome&amp;lt;double&amp;gt; o = Layer2NX::fun()) return o.</description>
    </item>
    
    <item>
      <title>Result only</title>
      <link>https://ned14.github.io/outcome/tutorial/policies/result-policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/policies/result-policies/</guid>
      <description>These are the precanned policies suitable for use with result:
 error_code_throw_as_system_error&amp;lt;EC&amp;gt; Policy interpreting EC as meeting the std::error_code contract. .value() will OUTCOME_THROW_EXCEPTION(std::system_error(error)) if there is no value, .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;quot;no error&amp;quot;)) if there is no error. The narrow checks call __builtin_unreachable() on compilers which support that intrinsic. error_enum_throw_as_system_error&amp;lt;EC&amp;gt; Policy interpreting make_error_code(EC) as meeting the std::error_code contract. .value() will OUTCOME_THROW_EXCEPTION(std::system_error(make_error_code(error))) if there is no value, .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;quot;no error&amp;quot;)) if there is no error.</description>
    </item>
    
    <item>
      <title>TRY operations</title>
      <link>https://ned14.github.io/outcome/tutorial/result/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/result/try/</guid>
      <description>In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRY:
OUTCOME_TRY (i, BigInt::fromString(text));  This control statement is raughly equivalent to:
auto&amp;amp;&amp;amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto&amp;amp;&amp;amp; i = __result.value();  Where __result is a unique name.
Additionally, in GCC and Clang which provide an extension to C++ known as statement expressions it is possible to use an alternative macro: OUTCOME_TRYX, which is an expression.</description>
    </item>
    
    <item>
      <title>Throwing filesystem_error</title>
      <link>https://ned14.github.io/outcome/tutorial/payload/copy_file3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/payload/copy_file3/</guid>
      <description>Telling Outcome how to throw a system error with payload is easy:
namespace filesystem2 { // For outcome&amp;#39;s with error_code + payload configuration, this free function is discovered by ADL  // and called to implement throwing the error code with payload.  template &amp;lt;class T&amp;gt; inline void throw_as_system_error_with_payload(const fs_result&amp;lt;T&amp;gt; *src) { // Throw the exact same filesystem_error exception which the throwing copy_file() edition does.  throw filesystem_error(src-&amp;gt;error().message(), src-&amp;gt;payload().path1, src-&amp;gt;payload().path2, src-&amp;gt;error()); } }  View this code on Github Note that if you configure outcome&amp;lt;T, EC, P&amp;gt; in the error code + payload edition and forget to define this free function, if you then write code which could throw the error code + payload as an exception, you will get a helpful compile time error message reminding you that you have forgotten to define this function.</description>
    </item>
    
    <item>
      <title>error_code</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/error-codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/error-codes/</guid>
      <description>Now that we have told the C++ standard library about our custom error code enum err, we actually no longer need to specify EC = err, we can just leave it default to std::error_code:
result&amp;lt;udt /*, std::error_code */&amp;gt; res(err::failure1); // What happens here? What exception type is thrown?  try { std::cout &amp;lt;&amp;lt; *res.value() &amp;lt;&amp;lt; std::endl; } catch(const std::exception &amp;amp;e) { // Prints &amp;#34;Exception thrown was failure1&amp;#34;, exactly the same as before  std::cerr &amp;lt;&amp;lt; &amp;#34;Exception thrown was &amp;#34; &amp;lt;&amp;lt; e.</description>
    </item>
    
    <item>
      <title>Custom exception ptr</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/poke_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/poke_exception/</guid>
      <description>If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.
But let&amp;rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:</description>
    </item>
    
    <item>
      <title>Outcome only</title>
      <link>https://ned14.github.io/outcome/tutorial/policies/outcome-policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/policies/outcome-policies/</guid>
      <description>These are the precanned policies suitable for use with outcome:
 error_code_throw_as_system_error_exception_rethrow&amp;lt;R, S, P&amp;gt; Policy interpreting S as meeting the std::error_code contract, and P as meeting the std::exception_ptr contract. If there is no value, .value() will std::rethrow_exception(exception) if there is an exception, else OUTCOME_THROW_EXCEPTION(std::system_error(error)). .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;quot;no error&amp;quot;)) if there is no error. .exception() will OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;quot;no exception&amp;quot;)) if there is no exception. The narrow checks call __builtin_unreachable() on compilers which support that intrinsic.</description>
    </item>
    
    <item>
      <title>Variations</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/variations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/variations/</guid>
      <description>You can of course choose your own E type so long as it has standard layout and is trivially copyable. You would declare that with CXX_DECLARE_RESULT(t_ident, t_decl, e_ident, e_decl), refer to it with CXX_RESULT(t_ident, e_ident) and need to do your own decoding of errors from your E type. By using the _EC postfixed macros, you are in fact using E =
struct cxx_error_code { int code; void *category; };  &amp;hellip; which is declared for you by result.</description>
    </item>
    
    <item>
      <title>exception_ptr</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/exception-ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/exception-ptr/</guid>
      <description>Another default action exists for result&amp;lt;T, EC&amp;gt; where trait::is_exception_ptr&amp;lt;EC&amp;gt; is true, and for outcome&amp;lt;T, EC, EP&amp;gt; where trait::is_exception_ptr&amp;lt;EP&amp;gt; is true.
This default action simply rethrows the exception pointer via std::rethrow_exception(.error()) for result and std::rethrow_exception(.exception()) for outcome.
struct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; result&amp;lt;udt, std::exception_ptr&amp;gt; res(std::make_exception_ptr(std::runtime_error(&amp;#34;hello&amp;#34;))); // What happens here? What exception type is thrown?</description>
    </item>
    
    <item>
      <title>result returning constructors</title>
      <link>https://ned14.github.io/outcome/tutorial/result/constructors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/result/constructors/</guid>
      <description>todo</description>
    </item>
    
    <item>
      <title>Hook outcome</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/hook_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/hook_outcome/</guid>
      <description>The final step is to add ADL discovered event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result. There isn&amp;rsquo;t really much to say about these, just be careful to mark them noexcept or not based on whether the types T, EC or EP could throw during copy or move construction. As poke_exception() creates a std::string and appends to it, it could indeed throw an exception and thus with the noexcept hooks below, the process would be terminated.</description>
    </item>
    
    <item>
      <title>void</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/void/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/void/</guid>
      <description>What about result&amp;lt;udt, void&amp;gt;? This is absolutely legal, it means that no error state is returned when there was an error. This can help with clarifying in code the use of std::optional&amp;lt;udt&amp;gt; as Optional more logically means value-or-nothing, not necessarily value-or-error. result&amp;lt;udt, void&amp;gt; unambiguously does mean success-or-failure, just with an unspecified cause of failure.
Outcome&amp;rsquo;s default action for EC = void is to call std::terminate:
struct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; result&amp;lt;udt, void&amp;gt; res(in_place_type&amp;lt;void&amp;gt;); // What happens here?</description>
    </item>
    
    <item>
      <title>unchecked&lt;T, E&gt; and checked&lt;T, E&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/default-actions/unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/default-actions/unchecked/</guid>
      <description>We have now covered all of the default actions in Outcome whereby result&amp;lt;T, EC&amp;gt; and outcome&amp;lt;T, EC, EP|P&amp;gt; implement various default actions upon incorrect observation according to traits defined upon the EC and EP|P chosen.
If you don&amp;rsquo;t want all this clever automatic detection of traits, and just want a plain, always-undefined-behaviour-on-incorrect-observation success-or-failure type, we provide a simplified template alias to result&amp;lt;T, E&amp;gt; called unchecked&amp;lt;T, E&amp;gt;. It literally does no run time checking whatsoever, incorrect observation is always undefined behaviour.</description>
    </item>
    
    <item>
      <title>Custom error codes</title>
      <link>https://ned14.github.io/outcome/tutorial/error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/error_code/</guid>
      <description>This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ned14.github.io/outcome/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/_header/</guid>
      <description>Outcome 2.0 library documentation</description>
    </item>
    
    <item>
      <title>Acknowledgements</title>
      <link>https://ned14.github.io/outcome/credits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/credits/</guid>
      <description>github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 695 commits   @akrzemi1 10 commits   @jenkins-nedprod 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation.</description>
    </item>
    
  </channel>
</rss>